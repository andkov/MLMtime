{
    "contents" : "# R scripts for extracting and plotting data stored in Mplus graphic\n# information in GH5 files.  Uses the rhdf5 package for loading the\n# the GH5 file.\n#\n# Version history:\n# 2013-09-13 File Version 3 for Mplus Version 7.3\n# 2014-04-30 Fix for sample and estimated means.\n# 2014-10-07 Fix IRT ICC and IIC functions, turning properties into integers\n# 2014-10-08 Add functions for Discrete survival curves\n# 2014-11-20 Fix estimated probabilities function, turning categories into integers.\n# 2014-11-21 Add legend to plot of estimated probabilities.\n#\n#\n# Written by: Thuy Nguyen\n#             Muthen & Muthen\n#\n# Reference:\n#\n# Bernd Fischer and Gregoire Pau (). rhdf5: HDF5 interface to R. R\n# package version 2.4.0.\n#\n\nif (require(rhdf5,quietly=TRUE)) {\n\tprint(\"Loaded rhdf5 package\")\n} else {\n\tprint(\"trying to install rhdf5 from bioconductor.org\")\n\tsource(\"http://bioconductor.org/biocLite.R\")\n\tbiocLite(\"rhdf5\")\n\tif (require(rhdf5)) {\n\t\tprint(\"Loaded missing rhdf5 package \")\n\t} else {\n\t\tstop(\"could not install rhdf5\")\n\t}\n}\n\n##########################################################################\n#\n# mplus.view.plots - loads the file and lists all available plots\n#\n# arguments:\n#    file - the quoted name of an existing GH5 file\n#\n# eg. mplus.view.plots('ex.gh5')\n#\nmplus.view.plots <- function(file) {\n\tmplus.load(file)\n}\n\n\n##########################################################################\n#\n# mplus.load - loads the file and lists all available plots\n#\n# arguments:\n#    file - the quoted name of an existing GH5 file\n#\n# eg. mplus.load('ex.gh5')\n#\nmplus.load <- function(file) {\n\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tcat(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\tcat(c(\"\\nPlot functions:\\n\"))\n\n\tif (\"individual_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.plot.histogram\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.histogram('\"),file,\"',variable,bins)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.scatterplot\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.scatterplot('\"),file,\"',xvar,yvar)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"process_data\" %in% names(gh5) && \"means_and_variances_data\" %in% names(gh5)) {\n\t\tnp <- length(attr(gh5$process_data,\"names\"))\n\t\tfor (i in c(1:np)) {\n\t\t\tcstr <- paste(c(\"process\"), as.character(i), sep=\"\")\n\t\t\tproc <- gh5$process_data[[cstr]]\n\n\t\t\t# Replace the line below with series of low-level function calls\n\t\t\tcstr2 <- paste(c(\"process_data\"),\"/\",cstr,\"\", sep=\"\")\n\t\t\tprop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n\t\t\tvalues <- attr(gh5$means_and_variances_data,\"names\")\n\n\t\t\tif (prop[1] == 1) {\n\t\t\t\tsm_ind <- pmatch(\"y_observed_means\",values,nomatch=0)\n\t\t\t\tif (sm_ind > 0 && exists(\"mplus.plot.sample_means\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.sample_means('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"y_estimated_means\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.estimated_means\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.estimated_means('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tif (sm_ind>0 && em_ind>0 && exists(\"mplus.plot.sample_and_estimated_means\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.sample_and_estimated_means('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"y_estimated_modes\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.estimated_modes\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.estimated_modes('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"y_estimated_medians\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.estimated_medians\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.estimated_medians('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\t\t\t} else if (prop[1] == 2) {\n\t\t\t\tem_ind <- pmatch(\"e_estimated_means\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.estimated_means\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.estimated_means('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"e_estimated_modes\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.estimated_modes\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.estimated_modes('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"e_estimated_medians\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.estimated_medians\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.estimated_medians('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\t\t\t} else if (prop[1] == 3) {\n\t\t\t\tem_ind <- pmatch(\"observed_probs\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.sample_proportions\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.sample_proportions('\"),file,\"','\",cstr,\"',cat1,cat2)\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"estimated_probs\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.plot.estimated_probabilities\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.plot.estimated_probabilities('\"),file,\"','\",cstr,\"',cat1,cat2)\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcstr2 <- paste(c(\"'\"),cstr,\"' has unknown series type.\\n\")\n\t\t\t\tcat(cstr2)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (\"loop_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.list.loop.labels\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.list.loop.labels('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.loop\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.loop('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"irt_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.list.irt.variables\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.list.irt.variables('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.list.irt.xvariables\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.list.irt.xvariables('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.irt.icc\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.irt.icc('\"),file,\"',group,xvar,uvar,cat,cat2,covariates,xrange,xstep,lloc)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.irt.iic\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.irt.iic('\"),file,\"',group,xvar,uvar,covariates,xrange,xstep,lloc)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.irt.tic\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.irt.tic('\"),file,\"',group,xvar,uvar,covariates,xrange,xstep)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"survival_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.plot.survival.kaplanmeier\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.survival.kaplanmeier('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.survival.baseline\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.survival.baseline('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.survival.basehazard\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.survival.basehazard('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.survival.sample.logcumulative\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.survival.sample.logcumulative('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.survival.estimated.logcumulative\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.survival.estimated.logcumulative('\"),file,\"',survar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.survival.kaplanmeier.vs.baseline\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.survival.kaplanmeier.vs.baseline('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.survival.sample.vs.estimated.logcumulative\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.survival.sample.vs.estimated.logcumulative('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"discrete_survival_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.plot.discrete.survival.kaplanmeier\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.discrete.survival.kaplanmeier('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.discrete.survival.baseline\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.discrete.survival.baseline('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.plot.discrete.survival.kaplanmeier.vs.baseline\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.plot.discrete.survival.kaplanmeier.vs.baseline('\"),file,\"',survvar,classnum)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"bayesian_data\" %in% names(gh5)) {\n\t\tif (\"parameters_autocorr\" %in% names(gh5$bayesian_data)) {\n\t\t\tif (\"parameters\" %in% names(gh5$bayesian_data$parameters_autocorr)) {\n\t\t\t\tif (exists(\"mplus.list.bayesian.parameters\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.list.bayesian.parameters('\"),file,\"',parameter)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t\tif (exists(\"mplus.plot.bayesian.traceplot\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.plot.bayesian.traceplot('\"),file,\"',parameter)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t\tif (exists(\"mplus.plot.bayesian.distribution\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.plot.bayesian.distribution('\"),file,\"',parameter,bins)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\"priors\" %in% names(gh5$bayesian_data$parameters_autocorr)) {\n\t\t\t\tif (exists(\"mplus.plot.bayesian.prior.distribution\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.plot.bayesian.prior.distribution('\"),file,\"',parameter,bins)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\"autocorrelation\" %in% names(gh5$bayesian_data$parameters_autocorr)) {\n\t\t\t\tif (exists(\"mplus.plot.bayesian.autocorrelation\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.plot.bayesian.autocorrelation('\"),file,\"',parameter,chain)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"predictive\" %in% names(gh5$bayesian_data)) {\n\t\t\tif (exists(\"mplus.list.bayesian.predictive.labels\",mode=\"function\")) {\n\t\t\t\tcat(c(\" - mplus.list.bayesian.predictive.labels('\"),file,\"')\\n\",sep=\"\")\n\t\t\t}\n\t\t\tif (\"observed\" %in% names(gh5$bayesian_data$predictive) && \"replicated\" %in% names(gh5$bayesian_data$predictive)) {\n\t\t\t\tif (exists(\"mplus.plot.bayesian.predictive.scatterplot\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.plot.bayesian.predictive.scatterplot('\"),file,\"',plabel)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t\tif (exists(\"mplus.plot.bayesian.predictive.distribution\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.plot.bayesian.predictive.distribution('\"),file,\"',plabel,bins)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"plausible\" %in% names(gh5$bayesian_data)) {\n\t\t\tif (exists(\"mplus.list.bayesian.plausible.labels\",mode=\"function\")) {\n\t\t\t\tcat(c(\" - mplus.list.bayesian.plausible.labels('\"),file,\"')\\n\",sep=\"\")\n\t\t\t}\n\t\t\tif (exists(\"mplus.plot.bayesian.plausible.distribution\",mode=\"function\")) {\n\t\t\t\tcat(c(\" - mplus.plot.bayesian.plausible.distribution('\"),file,\"',plauslabel,obs,bins)\\n\",sep=\"\")\n\t\t\t}\n\t\t}\n\t}\n\n\tcat(c(\"\\nPlot data extraction functions:\\n\"))\n\n\tif (\"individual_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.list.variables\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.list.variables('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.data\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.data('\"),file,\"',variable)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"process_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.list.processes\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.list.processes('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"loop_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.get.loop.estimates\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.loop.estimates('\"),file,\"',looplabel)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.loop.lowerci\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.loop.lowerci('\"),file,\"',looplabel)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.loop.upperci\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.loop.upperci('\"),file,\"',looplabel)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.loop.xvalues\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.loop.xvalues('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"irt_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.compute.irt.icc\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.compute.irt.icc('\"),file,\"',group,xvar,uvar,cat,xvector,covariates)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.compute.irt.iic\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.compute.irt.iic('\"),file,\"',group,xvar,uvar,xvector,covariates)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"process_data\" %in% names(gh5) && \"means_and_variances_data\" %in% names(gh5)) {\n\t\tnp <- length(attr(gh5$process_data,\"names\"))\n\t\tfor (i in c(1:np)) {\n\t\t\tcstr <- paste(c(\"process\"), as.character(i), sep=\"\")\n\t\t\tproc <- gh5$process_data[[cstr]]\n\n\t\t\t# Replace the line below with series of low-level function calls\n\t\t\tcstr2 <- paste(c(\"process_data\"),\"/\",cstr,\"\", sep=\"\")\n\t\t\tprop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n\t\t\tvalues <- attr(gh5$means_and_variances_data,\"names\")\n\n\t\t\tif (prop[1] == 1) {\n\t\t\t\tsm_ind <- pmatch(\"y_observed_means\",values,nomatch=0)\n\t\t\t\tif (sm_ind > 0 && exists(\"mplus.get.sample_means\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.sample_means('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"y_estimated_means\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.estimated_means\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.estimated_means('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"y_estimated_modes\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.estimated_modes\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.estimated_modes('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"y_estimated_medians\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.estimated_medians\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.estimated_medians('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\t\t\t} else if (prop[1] == 2) {\n\t\t\t\tem_ind <- pmatch(\"e_estimated_means\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.estimated_means\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.estimated_means('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"e_estimated_modes\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.estimated_modes\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.estimated_modes('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"e_estimated_medians\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.estimated_medians\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.estimated_medians('\"),file,\"','\",cstr,\"')\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\t\t\t} else if (prop[1] == 3) {\n\t\t\t\tem_ind <- pmatch(\"observed_probs\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.sample_proportions\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.sample_proportions('\"),file,\"','\",cstr,\"',cat1,cat2)\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\n\t\t\t\tem_ind <- pmatch(\"estimated_probs\",values,nomatch=0)\n\t\t\t\tif (em_ind > 0 && exists(\"mplus.get.estimated_probabilities\",mode=\"function\")) {\n\t\t\t\t\tcstr2 <- paste(c(\" - mplus.get.estimated_probabilities('\"),file,\"','\",cstr,\"',cat1,cat2)\\n\",sep=\"\")\n\t\t\t\t\tcat(cstr2)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcstr2 <- paste(c(\"'\"),cstr,\"' has unknown series type.\\n\")\n\t\t\t\tcat(cstr2)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (\"survival_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.list.survival.variables\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.list.survival.variables('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.survival.kaplanmeier.values\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.survival.kaplanmeier.values('\"),file,\"',survvar,classnum,time)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.compute.survival.sample.logcumulative.values\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.compute.survival.sample.logcumulative.values('\"),file,\"',survvar,classnum,time)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.survival.baseline.values\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.survival.baseline.values('\"),file,\"',survvar,survvar2,clasnum,time)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.compute.survival.estimated.logcumulative.values\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.compute.survival.estimated.logcumulative.values('\"),file,\"',survvar,classnum,time)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.survival.basehazard.values\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.survival.basehazard.values('\"),file,\"',file,survvar,classnum,time)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"discrete_survival_data\" %in% names(gh5)) {\n\t\tif (exists(\"mplus.list.discrete.survival.variables\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.list.discrete.survival.variables('\"),file,\"')\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.discrete.survival.kaplanmeier.values\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.discrete.survival.kaplanmeier.values('\"),file,\"',survvar,classnum,time)\\n\",sep=\"\")\n\t\t}\n\t\tif (exists(\"mplus.get.discrete.survival.baseline.values\",mode=\"function\")) {\n\t\t\tcat(c(\" - mplus.get.discrete.survival.baseline.values('\"),file,\"',survvar,survvar2,clasnum,time)\\n\",sep=\"\")\n\t\t}\n\t}\n\n\tif (\"bayesian_data\" %in% names(gh5)) {\n\t\tif (\"parameters_autocorr\" %in% names(gh5$bayesian_data)) {\n\t\t\tif (\"parameters\" %in% names(gh5$bayesian_data$parameters_autocorr)) {\n\t\t\t\tif (exists(\"mplus.get.bayesian.parameter.data\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.parameter.data('\"),file,\"',parameter,chain)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\"priors\" %in% names(gh5$bayesian_data$parameters_autocorr)) {\n\t\t\t\tif (exists(\"mplus.get.bayesian.prior.parameter.data\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.prior.parameter.data('\"),file,\"',parameter)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\"autocorrelation\" %in% names(gh5$bayesian_data$parameters_autocorr)) {\n\t\t\t\tif (exists(\"mplus.get.bayesian.autocorrelation\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.autocorrelation('\"),file,\"',parameter,chain)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"predictive\" %in% names(gh5$bayesian_data)) {\n\t\t\tif (\"observed\" %in% names(gh5$bayesian_data$predictive)) {\n\t\t\t\tif (exists(\"mplus.get.bayesian.predictive.observed\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.predictive.observed('\"),file,\"',plabel)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\"replicated\" %in% names(gh5$bayesian_data$predictive)) {\n\t\t\t\tif (exists(\"mplus.get.bayesian.predictive.replicated\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.predictive.replicated('\"),file,\"',plabel)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\"pvalues\" %in% names(gh5$bayesian_data$predictive)) {\n\t\t\t\tif (exists(\"mplus.get.bayesian.predictive.lowerci\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.predictive.lowerci('\"),file,\"',plabel)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t\tif (exists(\"mplus.get.bayesian.predictive.upperci\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.predictive.upperci('\"),file,\"',plabel)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t\tif (exists(\"mplus.get.bayesian.predictive.pvalue\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.predictive.pvalue('\"),file,\"',plabel)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t\tif (exists(\"mplus.get.bayesian.predictive.pvalue_type\",mode=\"function\")) {\n\t\t\t\t\tcat(c(\" - mplus.get.bayesian.predictive.pvalue('\"),file,\"',plabel)\\n\",sep=\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"plausible\" %in% names(gh5$bayesian_data)) {\n\t\t\tif (exists(\"mplus.get.bayesian.plausible.data\",mode=\"function\")) {\n\t\t\t\tcat(c(\" - mplus.get.bayesian.plausible.data('\"),file,\"',plauslabel,obs)\\n\",sep=\"\")\n\t\t\t}\n\t\t}\n\t}\n\n\tinvisible(file)\n}\n\n\n##########################################################################\n#\n# mplus.clear - clears all mplus-related data from a previous mplus_load\n#\n# arguments: none\n#\n# eg. mplus.clear()\n#\n#mplus.clear <- function() {\n#\tcat(c(\"\\nRemoved the following:\\n\"))\n#\n#\tif (exists(\"matrix_data\",)) {\n#\t    rm(matrix_data, inherits=TRUE)\n#\t\tcat(c(\" - matrix_data\\n\"))\n#\t}\n#\tif (exists(\"process_data\",)) {\n#\t    rm(process_data, inherits=TRUE)\n#\t\tcat(c(\" - process_data\\n\"))\n#\t}\n#\tif (exists(\"class_data\")) {\n#\t    rm(class_data, inherits=TRUE)\n#\t\tcat(c(\" - class_data\\n\"))\n#\t}\n#\tif (exists(\"categorical_data\")) {\n#\t    rm(categorical_data, inherits=TRUE)\n#\t\tcat(c(\" - categorical_data\\n\"))\n#\t}\n#\tif (exists(\"individual_data\")) {\n#\t    rm(individual_data, inherits=TRUE)\n#\t\tcat(c(\" - individual_data\\n\"))\n#\t}\n#\tif (exists(\"means_and_variances_data\")) {\n#\t    rm(means_and_variances_data, inherits=TRUE)\n#\t\tcat(c(\" - means_and_variances_data\\n\"))\n#\t}\n#}\n\n\n##########################################################################\n#\n# mplus.list.processes - list all available processes\n#\n# arguments:\n#    file - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.processes('ex8.1.gh5')\n#\nmplus.list.processes <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"mplus.list.proceses requires series information.\\n\\nUse the SERIES option in Mplus to specify series information.\\n\")\n\t}\n\n\tcat(c(\"\\nList of process names to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.plot.sample_means\\n\"))\t\n\tcat(c(\" - mplus.plot.estimated_means\\n\"))\t\n\tcat(c(\" - mplus.plot.sample_and_estimated_means\\n\"))\t\n\tcat(c(\" - mplus.plot.sample_proportions\\n\"))\t\n\tcat(c(\" - mplus.plot.estimated_probabilities\\n\"))\t\n\n\tcat(c(\" - mplus.get.sample_means\\n\"))\t\n\tcat(c(\" - mplus.get.estimated_means\\n\"))\t\n\tcat(c(\" - mplus.get.sample_proportions\\n\"))\t\n\tcat(c(\" - mplus.get.estimated_probabilities\\n\"))\t\n\n\tcat(c(\"\\nProcesses:\\n\"))\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tallpnames\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_means - plot estimated means for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.estimated_means('ex8.1.gh5','process1')\n#\nmplus.plot.estimated_means <-function(file,procstr='process1',ptype='o') {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated means.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 1 || series_type == 2) ) {\n\t\tcstr <- paste(\"- process does not have estimated means:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the time scores\n\txx <- proc$time_scores\n\n\t# set up the array for the estimated means\n\tdims <- attr(proc$time_scores,\"dim\")\n\tyy <- mplus.get.estimated_means(file,procstr)\n\n\t# plot the means\n\tcstr <- paste(\"Estimated means for\",procstr)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n\tsymb <- array(c(21,22,23,24,25),c(dims[1]))\n\tcolors <- rainbow(dims[2])\n\tfor (i in c(1:dims[2])) {\n\t\tlines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n\t}\n\n\tldesc <- array(0,c(dims[2]))\n\tlty <- array(0,c(dims[2]))\n\tlwd <- array(0,c(dims[2]))\n\tlcol <- array(0,c(dims[2]))\n\tfor (i in c(1:dims[2])) {\n\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\tlty[i] = 1\n\t\tlwd[i] = 2.5\n\t\tlcol[i] <- colors[i]\n\t}\n\tlegend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_modes - plot estimated modes for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.estimated_modes('ex8.1.gh5','process1')\n#\nmplus.plot.estimated_modes <-function(file,procstr='process1',ptype='o') {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated modes.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 1 || series_type == 2) ) {\n\t\tcstr <- paste(\"- process does not have estimated modes:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the time scores\n\txx <- proc$time_scores\n\n\t# set up the array for the estimated means\n\tdims <- attr(proc$time_scores,\"dim\")\n\tyy <- mplus.get.estimated_modes(file,procstr)\n\n\t# plot the means\n\tcstr <- paste(\"Estimated modes for\",procstr)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n\tsymb <- array(c(21,22,23,24,25),c(dims[1]))\n\tcolors <- rainbow(dims[2])\n\tfor (i in c(1:dims[2])) {\n\t\tlines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n\t}\n\n\tldesc <- array(0,c(dims[2]))\n\tlty <- array(0,c(dims[2]))\n\tlwd <- array(0,c(dims[2]))\n\tlcol <- array(0,c(dims[2]))\n\tfor (i in c(1:dims[2])) {\n\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\tlty[i] = 1\n\t\tlwd[i] = 2.5\n\t\tlcol[i] <- colors[i]\n\t}\n\tlegend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_medians - plot estimated medians for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.estimated_medians('ex8.1.gh5','process1')\n#\nmplus.plot.estimated_medians <-function(file,procstr='process1',ptype='o') {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated medians.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 1 || series_type == 2) ) {\n\t\tcstr <- paste(\"- process does not have estimated medians:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the time scores\n\txx <- proc$time_scores\n\n\t# set up the array for the estimated means\n\tdims <- attr(proc$time_scores,\"dim\")\n\tyy <- mplus.get.estimated_medians(file,procstr)\n\n\t# plot the means\n\tcstr <- paste(\"Estimated medians for\",procstr)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n\tsymb <- array(c(21,22,23,24,25),c(dims[1]))\n\tcolors <- rainbow(dims[2])\n\tfor (i in c(1:dims[2])) {\n\t\tlines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n\t}\n\n\tldesc <- array(0,c(dims[2]))\n\tlty <- array(0,c(dims[2]))\n\tlwd <- array(0,c(dims[2]))\n\tlcol <- array(0,c(dims[2]))\n\tfor (i in c(1:dims[2])) {\n\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\tlty[i] = 1\n\t\tlwd[i] = 2.5\n\t\tlcol[i] <- colors[i]\n\t}\n\tlegend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.sample_means - plot sample means for the quoted process\n#\n# arguments:\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.sample_means('ex6.1.gh5','process1')\n#\nmplus.plot.sample_means <-function(file,procstr='process1',ptype='o') {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample means.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n\tseries_type <- prop[1]\n\n\tif ( ! (series_type == 1) ) {\n\t\tcstr <- paste(\"- process does not have sample means:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the time scores\n\txx <- proc$time_scores\n\n\t# set up the array for the estimated means\n\tdims <- attr(proc$time_scores,\"dim\")\n\tyy <- mplus.get.sample_means(file,procstr)\n\n\t# plot the means\n\tcstr <- paste(\"Sample means for\",procstr)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n\tsymb <- array(c(21,22,23,24,25),c(dims[1]))\n\tcolors <- rainbow(dims[2])\n\tfor (i in c(1:dims[2])) {\n\t\tlines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n\t}\n\n\tldesc <- array(0,c(dims[2]))\n\tlty <- array(0,c(dims[2]))\n\tlwd <- array(0,c(dims[2]))\n\tlcol <- array(0,c(dims[2]))\n\tfor (i in c(1:dims[2])) {\n\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\tlty[i] = 1\n\t\tlwd[i] = 2.5\n\t\tlcol[i] <- colors[i]\n\t}\n\tlegend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.sample_and_estimated_means - plot sample and estimated means for the\n# quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.sample_and_estimated_means('process1')\n#\nmplus.plot.sample_and_estimated_means <-function(file,procstr='process1',ptype='o') {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample and estimated means.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 1) ) {\n\t\tcstr <- paste(\"- process does not have sample means:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the dimensions of the time_scores array and create an array with twice the size of the\n\t# first dimension\n\tdims <- attr(proc$time_scores,\"dim\")\n\txx <- array(0, c(dims[1],2*dims[2]))\n\tyy <- array(0, c(dims[1],2*dims[2]))\n\n\tsamp <- mplus.get.sample_means(file,procstr)\n\temean <- mplus.get.estimated_means(file,procstr)\n\n\tfor (i in c(1:dims[1])) {\n\t\tfor (j in c(1:dims[2])) {\n\t\t\t# set the time scores and pick up sample means\n\t\t\txx[i,2*j-1] <- proc$time_scores[i,j]\n\t\t\tyy[i,2*j-1] <- samp[i,j]\n\n\t\t\t# set the time scores and pick up estimated means\n\t\t\txx[i,2*j] <- proc$time_scores[i,j]\n\t\t\tyy[i,2*j] <- emean[i,j]\n\t\t}\n\t}\n\n\t# plot the means\n\tcstr <- paste(\"Sample and estimated means for\",procstr)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n\tsymb <- array(c(21,22,23,24,25),c(dims[2]))\n\tcolors <- rainbow(dims[2])\n\tfor (i in c(1:dims[2])) {\n\t\tlines(xx[,2*i-1],yy[,2*i-1],type=ptype,pch=symb[i],col=colors[i])\n\t\tlines(xx[,2*i],yy[,2*i],type=ptype,pch=symb[i],col=colors[i])\n\t}\n\n\tldesc <- array(0,c(2*dims[2]))\n\tlty <- array(0,c(2*dims[2]))\n\tlwd <- array(0,c(2*dims[2]))\n\tlcol <- array(0,c(2*dims[2]))\n\tlsymb <- array(0,c(2*dims[2]))\n\tfor (i in c(1:dims[2])) {\n\t\tldesc[2*i-1] <- sprintf(\"Sample means, Class %d\", i)\n\t\tlty[2*i-1] = 1\n\t\tlwd[2*i-1] = 2.5\n\t\tlsymb[2*i-1] <- symb[i]\n\n\t\tlcol[2*i] <- colors[i]\n\t\tldesc[2*i] <- sprintf(\"Estimated means, Class %d\", i)\n\t\tlty[2*i] = 1\n\t\tlwd[2*i] = 2.5\n\t\tlcol[2*i] <- colors[i]\n\t\tlsymb[2*i] <- symb[i]\n\t}\n\tlegend('bottomright',col=lcol,pch=lsymb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_probabilities - plot estimated probabilities for the\n# quoted process, summing up probabilities of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.plot.estimated_probabilities('ex8.4.gh5','process1',1,1)\n#\nmplus.plot.estimated_probabilities <- function(file,procstr='process1',cat1=1,cat2=1,ptype='o') {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated probabilities.\\n\")\n\t}\n\n\t# if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n\tif (missing(cat2)) {\n\t\tif (!(missing(cat1))) {\n\t\t\tcat2 <- cat1\n\t\t}\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\t# Replace the line below with series of low-level function calls\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( !(series_type == 3) ) {\n\t\tcstr <- paste(\"- process does not have estimated probabilities:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the time scores\n\txx <- proc$time_scores\n\n\t# set up the array for the estimated probabilities\n\tdims <- attr(proc$time_scores,\"dim\")\n\tyy <- mplus.get.estimated_probabilities(file,procstr,cat1,cat2)\n\n\t# plot the probabilities\n\tcstr <- paste(\"Estimated probabilities for\",procstr)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n',ylim=c(0:1))\n\tsymb <- array(c(21,22,23,24,25),c(dims[1]))\n\tcolors <- rainbow(dims[2])\n\tfor (i in c(1:dims[2])) {\n\t\tlines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n\t}\n\n\tldesc <- array(0,c(dims[2]))\n\tlty <- array(0,c(dims[2]))\n\tlwd <- array(0,c(dims[2]))\n\tlcol <- array(0,c(dims[2]))\n\tfor (i in c(1:dims[2])) {\n\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\tlty[i] = 1\n\t\tlwd[i] = 2.5\n\t\tlcol[i] <- colors[i]\n\t}\n\tlegend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.sample_proportions - plot sample proportions for the\n# quoted process, summing up proportions of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.plot.sample_proportions('ex8.4.gh5','process1',1,1)\n#\nmplus.plot.sample_proportions <-function(file,procstr='process1',cat1=1,cat2=1,ptype='o') {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample proportions.\\n\")\n\t}\n\n\t# if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n\tif (missing(cat2)) {\n\t\tif (!(missing(cat1))) {\n\t\t\tcat2 <- cat1\n\t\t}\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tcat(cstr)\n\t\treturn(invisible(cstr))\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( !(series_type == 3) ) {\n\t\tcstr <- paste(\"- process does not have sample proportions:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the time scores\n\txx <- proc$time_scores\n\n\t# set up the array for the sample proportions\n\tdims <- attr(proc$time_scores,\"dim\")\n\t# dims[1] is the number of time points, dims[2] is the number of classes\n\tyy <- mplus.get.sample_proportions(file,procstr,cat1,cat2)\n\n\t# plot the proportions\n\tcstr <- paste(\"Sample proportions for\",procstr)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n',ylim=c(0:1))\n\tsymb <- array(c(21,22,23,24,25),c(dims[1]))\n\tfor (k in c(1:dims[2])) {\n\t\tlines(xx[,k],yy[,k],type=ptype,pch=symb[k])\n\t}\n}\n\n\n##########################################################################\n#\n# mplus.get.estimated_means - plot estimated means for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.estimated_means('ex8.1.gh5','process1',3)\n#\nmplus.get.estimated_means <-function(file,procstr='process1',classidx=0) {\n\tif (missing(file)) {\n\t\tstop(\" - name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated means.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\t# Replace the line below with series of low-level function calls\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 1 || series_type == 2) ) {\n\t\tcstr <- paste(\"- process does not have estimated means:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# set up the array for the estimated means\n\tdims <- attr(proc$time_scores,\"dim\")\n\t# if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n\tif (classidx == 0) {\n\t\tyy <- array(0, c(dims[1],dims[2]))\n\t} else {\n\t\t# check that the classidx is within range.\n\t\tif (classidx < 0 || classidx > dims[2]) {\n\t\t\tcstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t\tyy <- array(0, c(dims[1],1))\n\t}\n\n\t# get the indices of variables in the series\n\tvar_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n\tif (series_type == 1) {\n\t\tmean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_estimated_means','variables')\n\t} else {\n\t\tmean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/e_estimated_means','variables')\n\t}\n\tvar_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n\t# type 1 is estimated means for observed variables\n\tif (series_type == 1) {\n\t\tif (classidx == 0) {\n\t\t\tfor (i in c(1:dims[2])) {\n\t\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_estimated_means$values[var_indices[j],i]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_estimated_means$values[var_indices[j],classidx]\n\t\t\t}\n\t\t}\n\t}\n\n\t# type 2 is estimated means for latent variables\n\tif (series_type == 2) {\n\t\tif (classidx == 0) {\n\t\t\tfor (i in c(1:dims[2])) {\n\t\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$e_estimated_means$values[var_indices[j],i]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$e_estimated_means$values[var_indices[j],classidx]\n\t\t\t}\n\t\t}\n\t}\n\n\t# return the means\n\treturn(yy)\n}\n\n\n##########################################################################\n#\n# mplus.get.sample_means - return sample means for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.sample_means('ex8.1.gh5','process1',3)\n#\nmplus.get.sample_means <- function(file,procstr='process1',classidx=0) {\n\tif (missing(file)) {\n\t\tstop(\"- the name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information.\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample means.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\t# Replace the line below with series of low-level function calls\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\n\tif ( ! (series_type == 1) ) {\n\t\tcstr <- paste(\"- process does not have sample means:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the time scores\n\txx <- proc$time_scores\n\n\t# set up the array for the estimated means\n\tdims <- attr(proc$time_scores,\"dim\")\n\t# if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n\tif (classidx == 0) {\n\t\tyy <- array(0, c(dims[1],dims[2]))\n\t} else {\n\t\t# check that the classidx is within range.\n\t\tif (classidx < 0 || classidx > dims[2]) {\n\t\t\tcstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t\tyy <- array(0, c(dims[1],1))\n\t}\n\n\t# get the indices of variables in the series\n\tvar_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n\tmean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_observed_means','variables')\n\tvar_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n\t# only type 1 has sample means\n\tif (classidx == 0) {\n\t\tfor (i in c(1:dims[2])) {\n\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_observed_means$values[var_indices[j],i]\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (j in c(1:dims[1])) {\n\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_observed_means$values[var_indices[j],classidx]\n\t\t}\n\t}\n\n\t# return the means\n\treturn(yy)\n}\n\n\n##########################################################################\n#\n# mplus.get.estimated_modes - plot estimated modes for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.estimated_modes('ex8.1.gh5','process1',3)\n#\nmplus.get.estimated_modes <-function(file,procstr='process1',classidx=0) {\n\tif (missing(file)) {\n\t\tstop(\" - name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated modes.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\t# Replace the line below with series of low-level function calls\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 1 || series_type == 2) ) {\n\t\tcstr <- paste(\"- process does not have estimated modes:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# set up the array for the estimated modes\n\tdims <- attr(proc$time_scores,\"dim\")\n\t# if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n\tif (classidx == 0) {\n\t\tyy <- array(0, c(dims[1],dims[2]))\n\t} else {\n\t\t# check that the classidx is within range.\n\t\tif (classidx < 0 || classidx > dims[2]) {\n\t\t\tcstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t\tyy <- array(0, c(dims[1],1))\n\t}\n\n\t# get the indices of variables in the series\n\tvar_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n\tif (series_type == 1) {\n\t\tmean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_estimated_modes','variables')\n\t} else {\n\t\tmean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/e_estimated_modes','variables')\n\t}\n\tvar_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n\t# type 1 is estimated means for observed variables\n\tif (series_type == 1) {\n\t\tif (classidx == 0) {\n\t\t\tfor (i in c(1:dims[2])) {\n\t\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_estimated_modes$values[var_indices[j],i]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_estimated_modes$values[var_indices[j],classidx]\n\t\t\t}\n\t\t}\n\t}\n\n\t# type 2 is estimated means for latent variables\n\tif (series_type == 2) {\n\t\tif (classidx == 0) {\n\t\t\tfor (i in c(1:dims[2])) {\n\t\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$e_estimated_modes$values[var_indices[j],i]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$e_estimated_modes$values[var_indices[j],classidx]\n\t\t\t}\n\t\t}\n\t}\n\n\t# return the modes\n\treturn(yy)\n}\n\n\n\n##########################################################################\n#\n# mplus.get.estimated_medians - plot estimated medians for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.estimated_medians('ex8.1.gh5','process1',3)\n#\nmplus.get.estimated_medians <-function(file,procstr='process1',classidx=0) {\n\tif (missing(file)) {\n\t\tstop(\" - name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated medians.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\t# Replace the line below with series of low-level function calls\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 1 || series_type == 2) ) {\n\t\tcstr <- paste(\"- process does not have estimated medians:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# set up the array for the estimated medians\n\tdims <- attr(proc$time_scores,\"dim\")\n\t# if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n\tif (classidx == 0) {\n\t\tyy <- array(0, c(dims[1],dims[2]))\n\t} else {\n\t\t# check that the classidx is within range.\n\t\tif (classidx < 0 || classidx > dims[2]) {\n\t\t\tcstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t\tyy <- array(0, c(dims[1],1))\n\t}\n\n\t# get the indices of variables in the series\n\tvar_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n\tif (series_type == 1) {\n\t\tmean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_estimated_medians','variables')\n\t} else {\n\t\tmean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/e_estimated_medians','variables')\n\t}\n\tvar_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n\t# type 1 is estimated means for observed variables\n\tif (series_type == 1) {\n\t\tif (classidx == 0) {\n\t\t\tfor (i in c(1:dims[2])) {\n\t\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_estimated_medians$values[var_indices[j],i]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$y_estimated_medians$values[var_indices[j],classidx]\n\t\t\t}\n\t\t}\n\t}\n\n\t# type 2 is estimated means for latent variables\n\tif (series_type == 2) {\n\t\tif (classidx == 0) {\n\t\t\tfor (i in c(1:dims[2])) {\n\t\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$e_estimated_medians$values[var_indices[j],i]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j in c(1:dims[1])) {\n\t\t\t\tyy[j,i] <- gh5$means_and_variances_data$e_estimated_medians$values[var_indices[j],classidx]\n\t\t\t}\n\t\t}\n\t}\n\n\t# return the modes\n\treturn(yy)\n}\n\n\n\n##########################################################################\n#\n# mplus.get.time_scores - return time scores for the quoted process\n#\n# arguments:\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.get.time_scores('ex6.1.gh5', 'process1')\n#\nmplus.get.time_scores <- function(file,procstr='process1') {\n\tif (missing(file)) {\n\t\tstop(\"- the name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information.\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample means.\\n\")\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\t# Replace the line below with series of low-level function calls\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\n\t# get the time scores\n\txx <- proc$time_scores\n\treturn(xx)\n}\n\n\n\n##########################################################################\n#\n# mplus.get.estimated_probabilities - return estimated probabilities for the\n# quoted process, summing up probabilities of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.get.estimated_probabilities('ex8.4.gh5','process1',1,1)\n#\nmplus.get.estimated_probabilities <- function(file,procstr='process1',cat1=1,cat2=1) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated probabilities.\\n\")\n\t}\n\n\t# if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n\tif (missing(cat2)) {\n\t\tif (!(missing(cat1))) {\n\t\t\tcat2 <- cat1\n\t\t}\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( !(series_type == 3) ) {\n\t\tcstr <- paste(\"- process does not have estimated probabilities:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# set up the array for the estimated probabilities\n\tdims <- attr(proc$time_scores,\"dim\")\n\tyy <- array(0, c(dims[1],dims[2]))\n\n\t# get indices and names of the variables in the series\n\tvar_indices <- mplus.get.group.attribute(file,cstr2,'var_indices')\n\tvar_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n\t# get categorical data information then look up the variables in the process\n\t# in categorical_data so we can get the number of categories for each variable in the process\n\t# this would be achieved by categories[cat_indices[i]] for variable i in the process\n\tcategories <- mplus.get.group.attribute(file,'categorical_data','categories')\n\n\tcatvars <- mplus.get.group.attribute(file,'categorical_data','var_names')\n\tcat_indices <- pmatch(var_names, catvars, nomatch=0)\n\n\t# get the probabilities\n\tfor (i in c(1:dims[1])) {\n\t\tfor (j in c(1:dims[2])) {\n\t\t\tstart_index <- sum(as.integer(categories[1:cat_indices[i]-1]))\n\n\t\t\tstartk <- cat1 + start_index\n\t\t\tendk <- cat2 + start_index\n\t\t\tyy[i,j] <- sum(gh5$means_and_variances_data$estimated_probs$values[startk:endk,j])\n\t\t}\n\t}\n\n\t# return the probabilities\n\treturn(yy);\n}\n\n\n\n\n##########################################################################\n#\n# mplus.get.sample_proportions - return sample proportions for the\n# quoted process, summing up proportions of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.get.sample_proportions('ex8.4.gh5','process1',1,1)\n#\nmplus.get.sample_proportions <-function(file,procstr='process1',cat1=1,cat2=1) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check that the series exists\n\tif (!(\"process_data\" %in% names(gh5))) {\n\t\tstop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample proportions.\\n\")\n\t}\n\n\tif (missing(procstr)) {\n\t\tstop(\"- requires the name of a series\\n\\nUse mplus.list.processes() to get the list of series processes.\")\n\t}\n\n\t# if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n\tif (missing(cat2)) {\n\t\tif (!(missing(cat1))) {\n\t\t\tcat2 <- cat1\n\t\t}\n\t}\n\n\tallpnames <- attr(gh5$process_data,\"names\")\n\tpind <- pmatch(procstr, allpnames, nomatch=0)\n\tif (pind == 0) {\n\t\tcstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the process\n\tproc <- gh5$process_data[[procstr]]\n\n\t# get the series type in properties\n\tcstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n\tprop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n\tseries_type <- prop[1]\n\tif ( ! (series_type == 3) ) {\n\t\tcstr <- paste(\"- process does not have sample proportions:\",procstr,\"\\n\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# set up the array for the sample proportions\n\tdims <- attr(proc$time_scores,\"dim\")\n\t# dims[1] is the number of time points, dims[2] is the number of classes\n\tyy <- array(0, c(dims[1],dims[2]))\n\n\t# get indices and names of the variables in the series\n\tvar_indices <- mplus.get.group.attribute(file,cstr2,'var_indices')\n\tvar_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n\t# get categorical data information then look up the variables in the process\n\t# in categorical_data so we can get the number of categories for each variable in the process\n\t# this would be achieved by categories[cat_indices[i]] for variable i in the process\n\tcategories <- mplus.get.group.attribute(file,'categorical_data','categories')\n\n\tcatvars <- mplus.get.group.attribute(file,'categorical_data','var_names')\n\tcat_indices <- pmatch(var_names, catvars, nomatch=0)\n\n\t# get the proportions\n\tfor (i in c(1:dims[1])) {\n\t\tfor (j in c(1:dims[2])) {\n\t\t\tstart_index <- sum(categories[1:cat_indices[i]-1])\n\n\t\t\tstartk <- cat1 + start_index\n\t\t\tendk <- cat2 + start_index\n\t\t\tyy[i,j] <- sum(gh5$means_and_variances_data$observed_probs$values[startk:endk,j])\n\t\t}\n\t}\n\n\t# return the proportions\n\treturn(yy)\n}\n\n\n\n##########################################################################\n#\n# mplus.list.variables - list the variables in individual data\n#\n# arguments: none\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.variables('ex8.1.gh5')\n#\nmplus.list.variables <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if individual data exists\n\tif ( !(\"individual_data\" %in% names(gh5)) ) {\n\t\tstop(\"mplus.list.variables requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data.\")\n\t}\n\n\tcat(c(\"\\nList of variable names to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.plot.histogram\\n\"))\n\tcat(c(\" - mplus.plot.scatterplot\\n\"))\n\tcat(c(\" - mplus.get.data\\n\"))\n\n\tcat(c(\"\\nVariables:\\n\"))\n\n\t# get the variable names from individual_data and lookup the indices\n\tvar_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n\tvar_names <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", var_names, perl=TRUE)\n\tvar_names\n}\n\n\n##########################################################################\n#\n# mplus.get.data - return the individual data for the quoted variable\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tv - name of variable to plot\n#\n# eg. mplus.get.data('ex8.1.gh5','y1')\n#\nmplus.get.data <- function(file,v) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# check that the series exists\n\tgh5 <- h5dump(file, load=TRUE)\n\n\tif (!(\"individual_data\" %in% names(gh5))) {\n\t\tstop(\"mplus.get.data requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data.\")\n\t}\n\n\tif (missing(v)) {\n\t\tstop(\"mplus.get.data requires the name of a variable.\\n\\nUse mplus.list.variables() to get the list of variable names.\")\n\t}\n\n\t# variables are stored in uppercase\n\tvar <- toupper(v)\n\n\t# get the variable names from individual_data and lookup the indices\n\tvar_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n\n\tindex <- pmatch(var, var_names, nomatch=0)\n\n\tif (index == 0) {\n\t\tcstr <- paste(c(\"Unknown variable:\"),var,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the data for the variable\n\txx <- gh5$individual_data$raw_data[index,]\n\txx\n}\n\n\n##########################################################################\n#\n# mplus.plot.scatterplot - plot the scatterplot for the 2 quoted variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\txv - name of variable on the x-axis\n#\tyv - name of variable on the y-axis\n#\n# eg. mplus.plot.scatterplot('ex8.1.gh5','y1','y2')\n#\nmplus.plot.scatterplot <- function(file, xv, yv) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if individual data exists\n\tif ( !(\"individual_data\" %in% names(gh5)) ) {\n\t\tstop(\"mplus.plot.scatterplot requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data\\nfor scatterplots.\")\n\t}\n\n\tif (missing(xv) || missing(yv)) {\n\t\tstop(\"mplus.plot.scatterplot requires the names of two variables.\\n\\nUse mplus.list.variables() to get the list of variable names.\")\n\t}\n\n\t# variables are stored in uppercase\n\txvar <- toupper(xv)\n\tyvar <- toupper(yv)\n\n\t# get the variable names from individual_data and lookup the indices\n\tvar_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n\n\txindex <- pmatch(xvar, var_names, nomatch=0)\n\tyindex <- pmatch(yvar, var_names, nomatch=0)\n\n\tif (xindex == 0) {\n\t\tcstr <- paste(c(\"Unknown x-variable:\"),xvar,\"\\n\")\n\t\tstop(cstr)\n\t}\n\tif (yindex == 0) {\n\t\tcstr <- paste(c(\"Unknown y-variable:\"),yvar,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\t# get the data for the 2 variables\n\txx <- mplus.get.data(file,xvar)\n\tyy <- mplus.get.data(file,yvar)\n\n\tplot(xx,yy,xlab=xvar,ylab=yvar)\n}\n\n\n##########################################################################\n#\n# mplus.plot.histogram - plot the histogram for the quoted variable, using the\n# specified number of bins (the default is 10 bins)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tv - name of variable to plot\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.histogram('y1',5)\n#\nmplus.plot.histogram <- function(file,v,bins=10) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if individual data exists\n\tif ( !(\"individual_data\" %in% names(gh5)) ) {\n\t\tstop(\"mplus.plot.histogram requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data\\nfor histograms.\")\n\t}\n\n\tif (missing(v)) {\n\t\tstop(\"mplus.plot.histogram requires the name of a variable.\\n\\nUse mplus.list.variables() to get the list of variable names.\")\n\t}\n\n\t# the number of bins should be greater than 0\n\tif (bins <= 0) {\n\t\tstop(\"The number of bins should be greater than 0.\")\n\t}\n\n\t# variables are stored in uppercase\n\tvar <- toupper(v)\n\n\t# get the variable names from individual_data and lookup the indices\n\tvar_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n\n\tindex <- pmatch(var, var_names, nomatch=0)\n\n\tif (index == 0) {\n\t\tcstr <- paste(c(\"Unknown variable:\"),var,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\txx <- mplus.get.data(file,v)\n\tcstr <- paste(c(\"Histogram of\"),var)\n\thist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab=var,right=TRUE)\n}\n\n\n######################################################################################################\n# Functions for BAYESIAN plots\n######################################################################################################\n\n\n#=========================================================================\n#\n# mplus.list.bayesian.parameters - list the parameters in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.bayesian.parameters('ex8.1.gh5')\n#\nmplus.list.bayesian.parameters <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"mplus.list.bayesian.parameters requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tcat(c(\"\\nList of parameters to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.plot.bayesian.trace_plots\\n\"))\n\n\tcat(c(\"\\nParameters:\\n\"))\n\n\t# get the parameter statements from bayesian_data and lookup the indices\n\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\tnplaus <- length(statements)\n\tfor (i in c(1:nplaus)) {\n\t\tcstr <- sprintf(\"[%d] %s\", i, statements[i])\n\t\tcat(cstr,sep=\"\\n\")\n\t}\n\tinvisible(statements)\n}\n\n#=========================================================================\n#\n# mplus.get.bayesian.parameter.data - get the bayesian data for the given parameter/chain\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   paramstr - the quoted name of a parameter or the parameter index\n#\tchainnum - the chain number\n#\n# eg. mplus.get.bayesian.parameter.data('ex8.1.gh5','parameter 1',1)\n#\nmplus.get.bayesian.parameter.data <- function(file,paramstr,chainnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (is.character(paramstr)) {\n\t\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\t\tstatements <- tolower(statements)\n\t\tparamstr <- tolower(paramstr)\n\t\tparamidx <- pmatch(paramstr, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"Unknown parameter:\"),paramstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# first dimension is the number of parameters\n\t\t# second dimension is the number of iterations\n\t\t# third dimension is the number of chains\n\t\tdims <- attr(gh5$bayesian_data$parameters_autocorr$parameters,\"dim\")\n\n\t\tparamidx <- paramstr\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\txx <- gh5$bayesian_data$parameters_autocorr$parameters[paramidx,,chainnum]\n\txx\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.prior.parameter.data - get the prior data for the given parameter\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted parameter label or the parameter index\n#\n# eg. mplus.get.bayesian.prior.parameter.data('ex8.1.gh5',1)\n#\nmplus.get.bayesian.prior.parameter.data <- function(file,paramstr) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\t# first dimension is the number of parameters\n\t# second dimension is the number of priors\n\tdims <- attr(gh5$bayesian_data$parameters_autocorr$priors,\"dim\")\n\n\tif (is.character(paramstr)) {\n\t\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\t\tstatements <- tolower(statements)\n\t\tparamstr <- tolower(paramstr)\n\t\tparamidx <- pmatch(paramstr, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# first dimension is the number of parameters\n\t\t# second dimension is the number of priors\n\t\tdims <- attr(gh5$bayesian_data$parameters_autocorr$priors,\"dim\")\n\n\t\tparamidx <- paramstr\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\txx <- gh5$bayesian_data$parameters_autocorr$priors[,paramidx]\n\txx\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.autocorrelation - get the autocorrelation data for the given parameter\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   paramidx - the quoted parameter label\n#   chainnum - the chain number\n#\n# eg. mplus.get.bayesian.autocorrelation('ex8.1.gh5','parameter 1',1)\n#\nmplus.get.bayesian.autocorrelation <- function(file,paramstr,chainnum=1) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\t# first dimension is the number of autocorrelation\n\t# second dimension is the number of parameters\n\t# third dimension is the number of chains\n\tdims <- attr(gh5$bayesian_data$parameters_autocorr$autocorrelation,\"dim\")\n\tif (is.character(paramstr)) {\n\t\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\t\tstatements <- tolower(statements)\n\t\tparamstr <- tolower(paramstr)\n\t\tparamidx <- pmatch(paramstr, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"Unknown parameter:\"),paramstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- paramstr\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tif (chainnum < 1 && chainnum > dims[3]) {\n\t\tcstr <- paste(\"- invalid chain number: \", chainnum,\"\\n\\nThe chain number must be between 1 and \", dims[3], \".\")\n\t\tstop(cstr)\n\t}\n\n\txx <- gh5$bayesian_data$parameters_autocorr$autocorrelation[,paramidx,chainnum]\n\txx\n}\n\n#=========================================================================\n#\n# mplus.plot.bayesian.traceplot - list the parameters in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   paramstr - the quoted name of a parameter\n#\n# eg. mplus.plot.bayesian.traceplot('ex8.1.gh5','parameter 1')\n#\nmplus.plot.bayesian.traceplot <- function(file,paramstr) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\t# get the dimensions of parameters array\n\t# first dimension is the number of parameters\n\t# second dimension is the number of iterations\n\t# third dimension is the number of chains\n\tdims <- attr(gh5$bayesian_data$parameters_autocorr$parameters,\"dim\")\n\n\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\n\tif (is.character(paramstr)) {\n\t\tlcstatements <- tolower(statements)\n\t\tparamstr <- tolower(paramstr)\n\t\tparamidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- paramstr\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\tlabel <- statements[paramidx]\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\txx <- array(0, c(dims[2],dims[3]))\n\tyy <- array(0, c(dims[2],dims[3]))\n\n\tfor (i in c(1:dims[3])) {\n\t\tyy[,i] <- mplus.get.bayesian.parameter.data(file, paramidx, i)\n\t}\n\tfor (i in c(1:dims[2])) {\n\t\txx[i,] <- i\n\t}\n\n\tcolors <- rainbow(dims[3])\n\n\n\tndist <- mplus.get.dataset.attribute(file, 'bayesian_data/parameters_autocorr/parameters', 'ndistribution')\n\n\t# plot the traceplot\n\tcstr <- paste(\"Trace plot of:\",label)\n\tplot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n\tfor (i in c(1:dims[3])) {\n\t\tlines(xx[,i],yy[,i],col=colors[i])\n\t}\n\tabline(v=ndist,untf=FALSE,col='red')\n}\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.distribution - plot the histogram for the parameter, using the\n# specified number of bins (the default is 100 bins)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted name of the parameter\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.bayesian.distribution('bayes.gh5','parameter 1',50)\n#\nmplus.plot.bayesian.distribution <- function(file,paramstr,bins=100) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(paramstr)) {\n\t\tstop(\"- requires the parameter label or index.\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\t# the number of bins should be greater than 0\n\tif (bins <= 0) {\n\t\tstop(\"The number of bins should be greater than 0.\")\n\t}\n\n\t# get the dimensions of parameters array\n\t# first dimension is the number of parameters\n\t# second dimension is the number of iterations\n\t# third dimension is the number of chains\n\tdims <- attr(gh5$bayesian_data$parameters_autocorr$parameters,\"dim\")\n\n\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\tif (is.character(paramstr)) {\n\t\tlcstatements <- tolower(statements)\n\t\tparamstr <- tolower(paramstr)\n\t\tparamidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- paramstr\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"Parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\tlabel <- statements[paramidx]\n\n\tndist <- mplus.get.dataset.attribute(file, 'bayesian_data/parameters_autocorr/parameters', 'ndistribution')\n\n\txxc <- array(0, c(dims[2],dims[3]))\n\txx <- array(0, c((dims[2]-ndist)*dims[3]))\n\tfor (i in c(1:dims[3])) {\n\t\txxc[,i] <- mplus.get.bayesian.parameter.data(file, paramidx, i)\n\t}\n\tstart <- 0\n\t#print(dims)\n\tfor (i in c(1:dims[3])) {\n\t\tfor (j in c((ndist+1):dims[2])) {\n\t\t\tstart <- start + 1\n\t\t\t#cstr <- paste(start, j, i)\n\t\t\t#print(cstr)\n\t\t\t#print(xxc[j,i])\n\t\t\txx[start] <- xxc[j,i]\n\t\t}\n\t}\n\n\tcstr <- paste(c(\"Distribution of:\"),label)\n\th <- hist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab='Estimate',ylab='Count')\n\n\txxmode <- h$mids[h$counts == max(h$counts)]\n\txxmean <- mean(xx)\n\txxsd <- sd(xx)\n\txxmedian <- median(xx)\n\n\tleft <- quantile(xx, 0.025)\n\tright <- quantile(xx, 0.975)\n\t\n\tabline(v=xxmode,untf=FALSE,col='green')\n\tabline(v=xxmean,untf=FALSE,col='brown')\n\tabline(v=xxmedian,untf=FALSE,col='purple')\n\tabline(v=left,untf=FALSE,col='blue')\n\tabline(v=right,untf=FALSE,col='blue')\n\n\tmodestr <- sprintf(\"Mode = %0.5f\", xxmode)\n\tmeanstr <- sprintf(\"Mean = %0.5f, Std Dev = %0.5f\", xxmean, xxsd)\n\tmedianstr <- sprintf(\"Median = %0.5f\", xxmedian)\n\tlowci <- sprintf(\"95%% Lower CI = %0.5f\", left)\n\tuppci <- sprintf(\"95%% Upper CI = %0.5f\", right)\n\tldesc <- c(meanstr, medianstr, modestr, lowci, uppci)\n\n\tlcol <- c('brown','purple','green','blue','blue')\n\tlegend(\"topright\",ldesc,col=lcol,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n\n\t#invisible(xx)\n}\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.prior.distribution - plot the histogram for the parameter, using the\n# specified number of bins (the default is 100 bins)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted name of the parameter\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.bayesian.prior.distribution('bayes.gh5','parameter 1',50)\n#\nmplus.plot.bayesian.prior.distribution <- function(file,paramstr,bins=100) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(paramstr)) {\n\t\tstop(\"- requires the parameter index\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\t# the number of bins should be greater than 0\n\tif (bins <= 0) {\n\t\tstop(\"- the number of bins should be greater than 0\")\n\t}\n\n\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\t# get the dimensions of parameters array\n\t# first dimension is the number of parameters\n\t# second dimension is the number of priors\n\tdims <- attr(gh5$bayesian_data$parameters_autocorr$priors,\"dim\")\n\n\tif (is.character(paramstr)) {\n\t\tlcstatements <- tolower(statements)\n\t\tparamstr <- tolower(paramstr)\n\t\tparamidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- paramstr\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\tplabel <- statements[paramidx]\n\n\txx <- mplus.get.bayesian.prior.parameter.data(file, paramidx)\n\n\tif (min(xx) == 999 && max(xx) == 999) {\n\t\tstop(\"- prior distributions for this parameter cannot be displayed because the prior is improper\")\n\t} else if (min(xx) == 998 && max(xx) == 998) {\n\t\tstop(\"- prior distributions for this parameter are not available\")\n\t}\n\n\tcstr <- paste(c(\"Prior distribution of:\"),plabel)\n\th <- hist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab='Estimate',ylab='Count')\n\n\txxmode <- h$mids[h$counts == max(h$counts)]\n\txxmean <- mean(xx)\n\txxsd <- sd(xx)\n\txxmedian <- median(xx)\n\n\tleft <- quantile(xx, 0.025)\n\tright <- quantile(xx, 0.975)\n\t\n\tabline(v=xxmode,untf=FALSE,col='green')\n\tabline(v=xxmean,untf=FALSE,col='brown')\n\tabline(v=xxmedian,untf=FALSE,col='purple')\n\tabline(v=left,untf=FALSE,col='blue')\n\tabline(v=right,untf=FALSE,col='blue')\n\n\tmodestr <- sprintf(\"Mode = %0.5f\", xxmode)\n\tmeanstr <- sprintf(\"Mean = %0.5f, Std Dev = %0.5f\", xxmean, xxsd)\n\tmedianstr <- sprintf(\"Median = %0.5f\", xxmedian)\n\tlowci <- sprintf(\"95%% Lower CI = %0.5f\", left)\n\tuppci <- sprintf(\"95%% Upper CI = %0.5f\", right)\n\tldesc <- c(meanstr, medianstr, modestr, lowci, uppci)\n\n\tlcol <- c('brown','purple','green','blue','blue')\n\tlegend(\"topright\",ldesc,col=lcol,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n\n\tinvisible(xx)\n}\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.autocorrelation - plot the autocorrelation histogram for the parameter\n#\tfor the given chain\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted name of the parameter\n#\tchainnum - the chain number\n#\n# eg. mplus.plot.bayesian.autocorrelation('bayes.gh5','parameter 1',1)\n#\nmplus.plot.bayesian.autocorrelation <- function(file,paramstr,chainnum=1) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian dat.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(paramstr)) {\n\t\tstop(\"- requires the parameter label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tstatements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\t# get the dimensions of parameters array\n\t# first dimension is the number of autocorrelations\n\t# second dimension is the number of parameters\n\t# third dimension is the number of chains\n\tdims <- attr(gh5$bayesian_data$parameters_autocorr$autocorrelation,\"dim\")\n\n\tif (is.character(paramstr)) {\n\t\tlcstatements <- tolower(statements)\n\t\tparamstr <- tolower(paramstr)\n\t\tparamidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- paramstr\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\tplabel <- statements[paramidx]\n\n\tif (chainnum < 1 && chainnum > dims[3]) {\n\t\tcstr <- paste(\"- invalid chain number: \", chainnum,\"\\n\\nThe chain number must be between 1 and \", dims[3], \".\")\n\t\tstop(cstr)\n\t}\n\n\tyy <- mplus.get.bayesian.autocorrelation(file,paramidx,chainnum)\n\txx <- as.character(1:dims[1])\n\n\tcstr <- paste(c(\"Autocorrelation (chain \"),format(chainnum),c(\"): \"),plabel)\n\tbarplot(yy,ylim=c(-1,1),names.arg=xx,col='red',main=cstr)\n\n\tinvisible(xx)\n}\n\n\n#=========================================================================\n#\n# mplus.list.bayesian.predictive.labels - list the parameters in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.bayesian.predictive.labels('ex8.1.gh5')\n#\nmplus.list.bayesian.predictive.labels <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tcat(c(\"\\nList of parameters to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.plot.bayesian.predictive.scatterplots\\n\"))\n\tcat(c(\" - mplus.plot.bayesian.predictive.distribution\\n\"))\n\n\tcat(c(\"\\nPredictive labels:\\n\"))\n\n\t# get the parameter statements from bayesian_data and lookup the indices\n\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\tstatements\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.observed - get the predictive observed data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.observed('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.observed <- function(file,plabel) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tif (is.character(plabel)) {\n\t\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\t\tstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of parameters array\n\t\t# first dimension is the number of ???\n\t\t# second dimension is the number of predictive labels\n\t\tdims <- attr(gh5$bayesian_data$predictive$observed,\"dim\")\n\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[2]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\txx <- gh5$bayesian_data$predictive$observed[,paramidx]\n\txx\n}\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.replicated - get the predictive replicated data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.replicated('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.replicated <- function(file,plabel) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tif (is.character(plabel)) {\n\t\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\t\tstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of parameters array\n\t\t# first dimension is the number of ???\n\t\t# second dimension is the number of predictive labels\n\t\tdims <- attr(gh5$bayesian_data$predictive$replicated,\"dim\")\n\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[2]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\txx <- gh5$bayesian_data$predictive$replicated[,paramidx]\n\txx\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.lowerci - get the predictive lower CI\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.lowerci('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.lowerci <- function(file,plabel) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tif (is.character(plabel)) {\n\t\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\t\tstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of parameters array\n\t\t# first dimension is the number of pvalues\n\t\t# second dimension is the number of predictive labels\n\t\tdims <- attr(gh5$bayesian_data$predictive$pvalues,\"dim\")\n\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[2]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tgh5$bayesian_data$predictive$pvalues[1,paramidx]\n}\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.upperci - get the predictive upper CI\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.upperci('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.upperci <- function(file,plabel) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tif (is.character(plabel)) {\n\t\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\t\tstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of parameters array\n\t\t# first dimension is the number of pvalues\n\t\t# second dimension is the number of predictive labels\n\t\tdims <- attr(gh5$bayesian_data$predictive$pvalues,\"dim\")\n\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[2]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tgh5$bayesian_data$predictive$pvalues[2,paramidx]\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.pvalue - get the predictive pvalue\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.pvalue('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.pvalue <- function(file,plabel) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tif (is.character(plabel)) {\n\t\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\t\tstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of parameters array\n\t\t# first dimension is the number of pvalues\n\t\t# second dimension is the number of predictive labels\n\t\tdims <- attr(gh5$bayesian_data$predictive$pvalues,\"dim\")\n\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[2]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tgh5$bayesian_data$predictive$pvalues[3,paramidx]\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.pvalue_type - get the predictive pvalue type\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.pvalue_type('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.pvalue_type <- function(file,plabel) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tptypes <- mplus.get.group.attribute(file,'/bayesian_data/predictive','types')\n\n\tif (is.character(plabel)) {\n\t\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\t\tstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, statements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of parameters array\n\t\t# first dimension is the number of pvalues\n\t\tdims <- attr(ptypes,\"dim\")\n\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tptypes[paramidx]\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.predictive.scatterplot - plot the predictive checking scatterplot\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the predictive label\n#\n# eg. mplus.plot.bayesian.predictive.scatterplot('bayes.gh5','label 1')\n#\nmplus.plot.bayesian.predictive.scatterplot <- function(file,plabel) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n\t}\n\n\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\tdims <- attr(statements,\"dim\")\n\n\tif (is.character(plabel)) {\n\t\tlcstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, lcstatements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\trep <- mplus.get.bayesian.predictive.replicated(file,paramidx)\n\tobs <- mplus.get.bayesian.predictive.observed(file,paramidx)\n\n\tomin <- min(obs)\n\tomax <- max(obs)\n\t\n\trmin <- min(rep)\n\trmax <- max(rep)\n\t\n\tif (omin < rmin) {\n\t\trmin <- omin\n\t}\n\tif (omax > rmax) {\n\t\trmax <- omax\n\t}\n\t\n\tplot(obs,rep,xlab='Observed',ylab='Replicated',xlim=c(rmin,rmax),ylim=c(rmin,rmax))\n#\tprint(rmin)\n#\tprint(rmax)\n\txx=c(rmin,rmax)\n\tyy=c(rmin,rmax)\n\tlines(xx,yy,col='green')\n\t#text(50,50,\"test\")\n\n\tlowci <- mplus.get.bayesian.predictive.lowerci(file,paramidx)\n\tuppci <- mplus.get.bayesian.predictive.upperci(file,paramidx)\n\tpval <- mplus.get.bayesian.predictive.pvalue(file,paramidx)\n\tptype <- mplus.get.bayesian.predictive.pvalue_type(file,paramidx)\n\n\tif (ptype == -1) {\n\t\ttext2 <- \"(Proportion of Points in the Lower Right Half)\";\n\t}\n\telse if (ptype == 1) {\n\t\ttext2 <- \"(Proportion of Points in the Upper Left Half)\";\n\t} else {\n\t\ttext2 <- \"(Smallest Proportion of Points in the Upper versus Lower Halves)\";\n\t}\n\n\t#ldesc <- sprintf(\"95%% Confidence Interval for the Difference\\n%0.3f     %0.3f\\nPosterior Predictive P-Value %0.3f\\n%s\",\n\t#\t\tlowci, uppci, pval, text2)\n\n\t#mtext(ldesc, side=3)\n\n\tline1 <- sprintf(\"95%% Confidence Interval for the Difference\")\n\tline2 <- sprintf(\"            %0.3f     %0.3f                \", lowci, uppci)\n\tline3 <- sprintf(\"\")\n\tline4 <- sprintf(\"   Posterior Predictive P-Value %0.3f      \", pval)\n\tline5 <- sprintf(\"\")\n\tline6 <- text2\n\n\tldesc <- c(line1,line2,line3,line4,line5,line6)\n\tlegend('topleft',ldesc,xjust=1)\n\n\ttitle(statements[paramidx])\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.predictive.distribution - plot the predictive checking distribution\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the predictive label\n#\tbins - the number of bins, default is 10\n#\n# eg. mplus.plot.bayesian.predictive.distribution('bayes.gh5','label 1')\n#\nmplus.plot.bayesian.predictive.distribution <- function(file,plabel,bins=100) {\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plabel)) {\n\t\tstop(\"- requires the index of the predictive label\\n\\nUse mplus.list.bayesian.predictive.labels() to get the list of parameters.\")\n\t}\n\n\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\tdims <- attr(statements,\"dim\")\n\n\tif (is.character(plabel)) {\n\t\tlcstatements <- tolower(statements)\n\t\tplabel <- tolower(plabel)\n\t\tparamidx <- pmatch(plabel, lcstatements, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- plabel\n\t\tif (paramidx < 1 || paramidx > dims[1]) {\n\t\t\tcstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\trep <- mplus.get.bayesian.predictive.replicated(file,paramidx)\n\tobs <- mplus.get.bayesian.predictive.observed(file,paramidx)\n\n\tomin <- min(obs)\n\tomax <- max(obs)\n\t\n\trmin <- min(rep)\n\trmax <- max(rep)\n\t\n\tif (omin < rmin) {\n\t\trmin <- omin\n\t}\n\tif (omax > rmax) {\n\t\trmax <- omax\n\t}\n\n\tnpred <- length(rep)\n\tvals <- array(c(npred))\n\tfor (i in c(1:npred)) {\n\t\tvals[i] <- obs[i] - rep[i]\n\t}\n\thist(vals,breaks=seq(min(vals),max(vals),length=bins+1),col=\"red\",main=statements[paramidx],xlab='Observed - Replicated',ylab='Count')\n\n\txxmedian <- median(vals)\n\tabline(v=xxmedian,untf=FALSE,col='purple')\n\n#\tprint(rmin)\n#\tprint(rmax)\n\txx=c(rmin,rmax)\n\tyy=c(rmin,rmax)\n\tlines(xx,yy,col='green')\n\t#text(50,50,\"test\")\n\n\tlowci <- mplus.get.bayesian.predictive.lowerci(file,paramidx)\n\tuppci <- mplus.get.bayesian.predictive.upperci(file,paramidx)\n\tpval <- mplus.get.bayesian.predictive.pvalue(file,paramidx)\n\n\t#ldesc <- sprintf(\"95%% Confidence Interval for the Difference\\n%0.3f     %0.3f\\nPosterior Predictive P-Value %0.3f\\n%s\",\n\t#\t\tlowci, uppci, pval, text2)\n\n\t#mtext(ldesc, side=3)\n\n\tline1 <- sprintf(\"95%% Confidence Interval for the Difference\")\n\tline2 <- sprintf(\"            %0.3f     %0.3f                \", lowci, uppci)\n\tline3 <- sprintf(\"\")\n\tline4 <- sprintf(\"   Posterior Predictive P-Value %0.3f      \", pval)\n\n\tldesc <- c(line1,line2,line3,line4)\n\tlegend('topleft',ldesc,xjust=1)\n}\n\n\n\n#=========================================================================\n#\n# mplus.list.bayesian.plausible.labels - list the plausible labels in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.bayesian.plausible.labels('ex8.1.gh5')\n#\nmplus.list.bayesian.plausible.labels <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"mplus.list.bayesian.plausible.labels requires bayesian data and factor scores.\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n\t}\n\n\t# check if plausible exists\n\tif ( !(\"plausible\" %in% names(gh5$bayesian_data)) ) {\n\t\tstop(\"mplus.list.bayesian.plausible.labels requires bayesian data factor scores.\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n\t}\n\n\tcat(c(\"\\nList of labels to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.plot.bayesian.plausible.distribution\\n\"))\n\n\tcat(c(\"\\nPlausible labels:\\n\"))\n\n\t# get the parameter statements from bayesian_data and lookup the indices\n\tstatements <- mplus.get.group.attribute(file, 'bayesian_data/plausible', 'plauslabels')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\tnplaus <- length(statements)\n\tfor (i in c(1:nplaus)) {\n\t\tcstr <- sprintf(\"[%d] %s\", i, statements[i])\n\t\tcat(cstr,sep=\"\\n\")\n\t}\n#\tcat(statements,sep=\"\\n\")\n\tinvisible(statements)\n}\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.plausible.data - get plausible data for the given plausible label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplauslabel - the plausible label or the index of the plausible label\n#\tobs - the observation index or 0 for overall\n#\n# eg. mplus.get.bayesian.plausible.data('ex8.1.gh5',1,obs)\n#\nmplus.get.bayesian.plausible.data <- function(file,plauslabel,obs=0) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n\t}\n\n\t# check if plausible exists\n\tif ( !(\"plausible\" %in% names(gh5$bayesian_data)) ) {\n\t\tstop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plauslabel)) {\n\t\tstop(\"- requires the plausible label\\n\\nUse mplus.list.bayesian.plausible.labels() to get the list of plausible labels.\")\n\t}\n\n\tif (is.character(plauslabel)) {\n\t\tlabels <- mplus.get.group.attribute(file,'bayesian_data/plausible','plauslabels')\n\t\tlabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n\t\tlabels <- tolower(labels)\n\t\tplauslabel <- tolower(plauslabel)\n\t\tparamidx <- pmatch(plauslabel, labels, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown plausible label:\"),plauslabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of plausible array\n\t\t# first dimension is the number of observations\n\t\t# second dimension is the number of imputations\n\t\t# third dimension is the number of labels\n\t\tdims <- attr(gh5$bayesian_data$plausible$plausible,\"dim\")\n\n\t\tparamidx <- plauslabel\n\t\tif (paramidx < 1 || paramidx > dims[3]) {\n\t\t\tcstr <- paste(\"- plausible label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.plausible.labels to see the list of plausible labels.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tif (obs == 0) {\n\t\txx <- array(0, c(dims[1]*dims[2]))\n\t\tstart <- 0\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tfor (j in c(1:dims[2])) {\n\t\t\t\tstart <- start + 1\n\t\t\t\txx[start] <- gh5$bayesian_data$plausible$plausible[i,j,paramidx]\n\t\t\t}\n\t\t}\n\t} else {\n\t\txx <- gh5$bayesian_data$plausible$plausible[obs,,paramidx]\n\t}\n\txx\n}\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.plausible.distribution - plot the histogram for the plausible label, using the\n# specified number of bins (the default is 100 bins for overall and 10 for a specific observation)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - name or index of variable to plot\n#\tobs - the observation number or 0\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.bayesian.plausible.distribution('bayes.gh5',1,0)\n#\nmplus.plot.bayesian.plausible.distribution <- function(file,plauslabel,obs=0,bins=100) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if bayesian data exists\n\tif ( !(\"bayesian_data\" %in% names(gh5)) ) {\n\t\tstop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n\t}\n\n\t# check if plausible exists\n\tif ( !(\"plausible\" %in% names(gh5$bayesian_data)) ) {\n\t\tstop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n\t}\n\n\tif (missing(plauslabel)) {\n\t\tstop(\"- requires the index of the plausible label\\n\\nUse mplus.list.bayesian.plausible.labels() to get the list of plausible labels.\")\n\t}\n\n\tif (missing(bins)) {\n\t\tif (obs == 0) {\n\t\t\tbins = 100\n\t\t} else {\n\t\t\tbins = 10\n\t\t}\n\t}\n\n\t# the number of bins should be greater than 0\n\tif (bins <= 0) {\n\t\tstop(\"- the number of bins should be greater than 0\")\n\t}\n\n\tlabels <- mplus.get.group.attribute(file,'bayesian_data/plausible','plauslabels')\n\tlabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n\tadim <- attr(labels,'dim')\n\n\tif (is.character(plauslabel)) {\n\t\tlclabels <- tolower(labels)\n\t\tplauslabel <- tolower(plauslabel)\n\t\tparamidx <- pmatch(plauslabel, lclabels, nomatch=0)\n\n\t\tif (paramidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown plausible label:\"),plauslabel,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tparamidx <- plauslabel\n\t\tif (paramidx < 1 || paramidx > adim[1]) {\n\t\t\tcstr <- paste(\"- plausible index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.plausible.labels to see the list of plausible labels.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\txx <- mplus.get.bayesian.plausible.data(file,paramidx,obs)\n\n\txxmax <- max(xx)\n\txxmin <- min(xx)\n#\tprint(xxmax)\n#\tprint(xxmin)\n\n\tif (obs == 0) {\n\t\tcstr <- paste(c(\"Overall distribution of\"),labels[paramidx])\n\t} else {\n\t\tcstr <- sprintf(\"Distribution of %s for Individual %d\", labels[paramidx], obs)\n\t}\n\th <- hist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab='Estimate',ylab='Count')\n\n\txxmode <- h$mids[h$counts == max(h$counts)]\n\txxmean <- mean(xx)\n\txxsd <- sd(xx)\n\txxmedian <- median(xx)\n\n\tleft <- quantile(xx, 0.025,type=3)\n\tright <- quantile(xx, 0.975,type=3)\n\t\n\tabline(v=xxmode,untf=FALSE,col='green')\n\tabline(v=xxmean,untf=FALSE,col='brown')\n\tabline(v=xxmedian,untf=FALSE,col='purple')\n\tabline(v=left,untf=FALSE,col='blue')\n\tabline(v=right,untf=FALSE,col='blue')\n\n\tmodestr <- sprintf(\"Mode = %0.5f\", xxmode)\n\tmeanstr <- sprintf(\"Mean = %0.5f, Std Dev = %0.5f\", xxmean, xxsd)\n\tmedianstr <- sprintf(\"Median = %0.5f\", xxmedian)\n\tlowci <- sprintf(\"95%% Lower CI = %0.5f\", left)\n\tuppci <- sprintf(\"95%% Upper CI = %0.5f\", right)\n\tldesc <- c(meanstr, medianstr, modestr, lowci, uppci)\n\n\tlcol <- c('brown','purple','green','blue','blue')\n\tlegend(\"topleft\",ldesc,col=lcol,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n\n\tinvisible(xx)\n}\n\n######################################################################################################\n# Functions for LOOP PLOT\n######################################################################################################\n\n#========================================================================\n#\n# mplus.list.loop.labels - list the loop variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.loop.labels('ex8.1.gh5')\n#\nmplus.list.loop.labels <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if loop data exists\n\tif ( !(\"loop_data\" %in% names(gh5)) ) {\n\t\tstop(\"mplus.list.loop.labels requires loop data.\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT or use the MOD keyword in MODEL INDIRECT.\")\n\t}\n\n\tcat(c(\"\\nList of loop labels to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.plot.loop\\n\"))\n\tcat(c(\" - mplus.get.loop.estimates\\n\"))\n\tcat(c(\" - mplus.get.loop.lowerci\\n\"))\n\tcat(c(\" - mplus.get.loop.upperci\\n\"))\n\tcat(c(\" - mplus.get.loop.xvalues\\n\"))\n\n\tcat(c(\"\\nLoop labels:\\n\"))\n\n\t# get the parameter statements from loop_data and lookup the indices\n\tstatements <- mplus.get.group.attribute(file, 'loop_data', 'labels')\n\tstatements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n\tnplaus <- length(statements)\n\tfor (i in c(1:nplaus)) {\n\t\tcstr <- sprintf(\"[%d] %s\", i, statements[i])\n\t\tcat(cstr,sep=\"\\n\")\n\t}\n#\tcat(statements,sep=\"\\n\")\n\tinvisible(statements)\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.estimates - get the estimates for the given loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopstr - the quoted loop label\n#\n# eg. mplus.get.loop.estimates('ex8.1.gh5','indirect')\n#\nmplus.get.loop.estimates <- function(file,loopstr=1) {\n\tif (missing(file)) {\n\t\tstop(\"- - name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\" - file does not exist:\",file)\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if loop data exists\n\tif ( !(\"loop_data\" %in% names(gh5)) ) {\n\t\tstop(\" - requires loop data\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n\t}\n\n\tif (missing(loopstr)) {\n\t\tloopstr=1\n\t}\n\n\tif (is.character(loopstr)) {\n\t\tlabels <- mplus.get.group.attribute(file,'loop_data','labels')\n\t\tlabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n        labels <- tolower(labels)\n\t\tloopstr <- toupper(loopstr)\n\t\tloopidx <- pmatch(loopstr, labels, nomatch=0)\n\n\t\tif (loopidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown loop label:\"),loopstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of the estimates dataset\n\t\t# first dimension is the number of loop labels\n\t\t# second dimension is the number of x points\n\t\tdims <- attr(gh5$loop_data$estimates,'dim')\n\n\t\tloopidx <- loopstr\n\t\tif (loopidx <= 0 || loopidx > dims[1]) {\n\t\t\tcstr <- paste(\" - loop index is out of range: \",loopidx,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tgh5$loop_data$estimates[loopidx,]\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.lowerci - get the lower CI values for the given loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopstr - the quoted loop label\n#\n# eg. mplus.get.loop.lowerci('ex8.1.gh5','indirect')\n#\nmplus.get.loop.lowerci <- function(file,loopstr=1) {\n\tif (missing(file)) {\n\t\tstop(\"- - name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\" - file does not exist:\",file)\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if loop data exists\n\tif ( !(\"loop_data\" %in% names(gh5)) ) {\n\t\tstop(\" - requires loop data\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n\t}\n\n\tif (missing(loopstr)) {\n\t\tloopstr=1\n\t}\n\n\tif (is.character(loopstr)) {\n\t\tlabels <- mplus.get.group.attribute(file,'loop_data','labels')\n\t\tlabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n        labels <- tolower(labels)\n\t\tloopstr <- tolower(loopstr)\n\t\tloopidx <- pmatch(loopstr, labels, nomatch=0)\n\n\t\tif (loopidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown loop label:\"),loopstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of the estimates dataset\n\t\t# first dimension is the number of loop labels\n\t\t# second dimension is the number of x points\n\t\tdims <- attr(gh5$loop_data$estimates,'dim')\n\n\t\tloopidx <- loopstr\n\t\tif (loopidx <= 0 || loopidx > dims[1]) {\n\t\t\tcstr <- paste(\" - loop index is out of range: \",loopidx,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tgh5$loop_data$lowerci[loopidx,]\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.upperci - get the upper CI values for the given loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopstr - the quoted loop label\n#\n# eg. mplus.get.loop.upperci('ex8.1.gh5','indirect')\n#\nmplus.get.loop.upperci <- function(file,loopstr=1) {\n\tif (missing(file)) {\n\t\tstop(\"- - name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\" - file does not exist:\",file)\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if loop data exists\n\tif ( !(\"loop_data\" %in% names(gh5)) ) {\n\t\tstop(\" - requires loop data\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n\t}\n\n\tif (missing(loopstr)) {\n\t\tloopstr=1\n\t}\n\n\tif (is.character(loopstr)) {\n\t\tlabels <- mplus.get.group.attribute(file,'loop_data','labels')\n\t\tlabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n        labels <- tolower(labels)\n\t\tloopstr <- tolower(loopstr)\n\t\tloopidx <- pmatch(loopstr, labels, nomatch=0)\n\n\t\tif (loopidx == 0) {\n\t\t\tcstr <- paste(c(\"- unknown loop label:\"),loopstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\t# get the dimensions of the estimates dataset\n\t\t# first dimension is the number of loop labels\n\t\t# second dimension is the number of x points\n\t\tdims <- attr(gh5$loop_data$estimates,'dim')\n\n\t\tloopidx <- loopstr\n\t\tif (loopidx <= 0 || loopidx > dims[1]) {\n\t\t\tcstr <- paste(\" - loop index is out of range: \",loopidx,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tgh5$loop_data$upperci[loopidx,]\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.xvalues - get the x points for the loop plots\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.get.loop.xvalues('ex8.1.gh5')\n#\nmplus.get.loop.xvalues <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if loop data exists\n\tif ( !(\"loop_data\" %in% names(gh5)) ) {\n\t\tstop(\"mplus.get.loop.upperci requires loop data.\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n\t}\n\n\tgh5$loop_data$xvalues\n}\n\n\n\n#========================================================================\n#\n# mplus.plot.loop - plot the loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopvar - the index of the loop label\n#\n# eg. mplus.plot.loop('ex8.1.gh5',1)\n#\nmplus.plot.loop <- function(file,loopstr=1) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if loop data exists\n\tif ( !(\"loop_data\" %in% names(gh5)) ) {\n\t\tstop(\"requires loop data.\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n\t}\n\n\tif (missing(loopstr)) {\n\t\tloopstr=1\n\t}\n\n\t# get the dimensions of the estimates dataset\n\t# first dimension is the number of loop labels\n\t# second dimension is the number of x points\n\tprops <- mplus.get.group.attribute(file,'loop_data','properties')\n\n\tif (is.character(loopstr)) {\n\t\t# get the parameter statements from loop_data and lookup the indices\n\t\tlabels <- mplus.get.group.attribute(file, 'loop_data', 'labels')\n\t\tlabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n        labels <- tolower(labels)\n\t\tloopstr <- tolower(loopstr)\n\t\tloopidx <- pmatch(loopstr, labels, nomatch=0)\n\n\t\tif (loopidx == 0) {\n\t\t\tcstr <- paste(c(\"Unknown loop label:\"),loopstr,\"\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t} else {\n\t\tif (loopstr <= 0 || loopstr > props[1]) {\n\t\t\tcstr <- paste(\"Loop index is out of range: \",loopvar,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n\t\t\tstop(cstr)\n\t\t}\n\t\tloopidx <- loopstr\n\t}\n\n\tlabels <- mplus.get.group.attribute(file,'loop_data','labels')\n\tlabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n\n\tloopvar <- mplus.get.group.attribute(file,'loop_data','loop_variable')\n\tloopvar <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", loopvar, perl=TRUE)\n\n\txx <- array(0,c(3,props[2]))\n\txx[1,] <- mplus.get.loop.xvalues(file)\n\txx[2,] <- mplus.get.loop.xvalues(file)\n\txx[3,] <- mplus.get.loop.xvalues(file)\n\n\tyy <- array(0,c(3,props[2]))\n\tyy[1,] <- mplus.get.loop.estimates(file,loopidx)\n\tyy[2,] <- mplus.get.loop.lowerci(file,loopidx)\n\tyy[3,] <- mplus.get.loop.upperci(file,loopidx)\n\n\t# plot the loop\n\tcstr <- paste(\"Loop plot for\",labels[loopidx])\n\tplot(xx,yy,xlab=loopvar,ylab=labels[loopidx],main=cstr,type='n')\n\n\tlines(xx[1,],yy[1,],col='red')\n\tlines(xx[2,],yy[2,],col='blue')\n\tlines(xx[3,],yy[3,],col='blue')\n\n#\tabline(v=0,untf=FALSE,col='black')\n#\tabline(h=0,untf=FALSE,col='black')\n\tgrid(NULL, NULL, lty=6, col='cornsilk2')\n}\n\n\n\n######################################################################################################\n# Functions for IRT plots\n######################################################################################################\n\n#========================================================================\n# mplus.list.irt.variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.irt.variables('ex7.27.gh5')\n#\nmplus.list.irt.variables <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if irt data exists\n\tif ( !(\"irt_data\" %in% names(gh5)) ) {\n\t\tstop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tcat(c(\"\\nList of variables to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.compute.irt.icc\\n\"))\n\tcat(c(\" - mplus.plot.irt.icc\\n\"))\n\n\tcat(c(\"\\nVariables for 'uvar' argument:\\n\"))\n\n\tulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n\tulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\n\tnvar <- length(ulabels)\n\tfor (i in c(1:nvar)) {\n\t\tcstr <- sprintf(\"[%d] %s\", i, ulabels[i])\n\t\tcat(cstr,sep=\"\\n\")\n\t}\n\tinvisible(ulabels)\n}\n\n\n#========================================================================\n# mplus.list.irt.xvariables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.irt.xvariables('ex7.27.gh5')\n#\nmplus.list.irt.xvariables <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if irt data exists\n\tif ( !(\"irt_data\" %in% names(gh5)) ) {\n\t\tstop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tcat(c(\"\\nList of variables to use in the following functions:\\n\"))\n\tcat(c(\" - mplus.compute.irt.icc\\n\"))\n\tcat(c(\" - mplus.plot.irt.icc\\n\"))\n\n\tcat(c(\"\\nVariables for the 'xvar' argument:\\n\"))\n\n\tflabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n\tflabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n\n\tnvar <- length(flabels)\n\tfor (i in c(1:nvar)) {\n\t\tcstr <- sprintf(\"[%d] %s\", i, flabels[i])\n\t\tcat(cstr,sep=\"\\n\")\n\t}\n\tinvisible(flabels)\n}\n\n#========================================================================\n# mplus.compute.irt.icc\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (required)\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (required)\n#\tuvar - the indicator variable, can be the variable index or the quoted variable name (required)\n#\tcat - the category number (required)\n#\txvector -> the vector containing x values to use (required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\n# eg. mplus.compute.irt.icc('ex7.27.gh5',1,'F','U1',1,seq(-3,3,0.2))\n#\nmplus.compute.irt.icc <- function(file,group,xvar,uvar,cat,xvector,covariates) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if irt data exists\n\tif ( !(\"irt_data\" %in% names(gh5)) ) {\n\t\tstop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\t#\tproperties[1] - number of factors\n\t#\tproperties[2] - number of factors/covariates\n\t#\tproperties[3] - number of indicators\n\t#\tproperties[4] - number of classes\n\t#\tproperties[5] - maximum number of categories \n\tprops <- mplus.get.group.attribute(file,'irt_data','properties')\n\n\tnum_fx <- as.integer(props[2])\n\tnum_r <- as.integer(props[3])\n\tmax_num_cat <- as.integer(props[5])\n\n\tflabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n\tflabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n\n\tulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n\tulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\n\tif (missing(xvar)) {\n\t\tstop(\"The x-axis variable (xvar) is required.\")\n\t} else {\n\t\tif (is.character(xvar)) {\n\t\t\txvar <- toupper(xvar)\n\t\t\tindex <- pmatch(xvar, flabels, nomatch=0)\n\t\t\tif (index == 0) {\n\t\t\t\tcstr <- sprintf(\"Unknown x-variable:  %s\\n\", xvar)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tfidx = index\n\t\t} else {\n\t\t\tif (xvar <= 0 || xvar > num_fx) {\n\t\t\t\tstop(\"The index for the x-variable (xvar) is out of range.\")\n\t\t\t}\n\t\t\tfidx = xvar\n\t\t}\n\t}\n\tif (missing(uvar)) {\n\t\tstop(\"The indicator variable (uvar) is required.\")\n\t} else {\n\t\tif (is.character(uvar)) {\n\t\t\tuvar <- toupper(uvar)\n\t\t\tindex <- pmatch(uvar, ulabels, nomatch=0)\n\t\t\tif (index == 0) {\n\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tridx = index\n\t\t} else {\n\t\t\tif (uvar <= 0 || uvar > num_r) {\n\t\t\t\tstop(\"The index for the indicator (uvar) is out of range.\")\n\t\t\t}\n\t\t\tridx = uvar\n\t\t}\n\t}\n\tif (missing(group)) {\n\t\tstop(\"The group index (group) is required.\")\n\t} else {\n\t\tif (group <= 0 || group > props[4]) {\n\t\t\tstop(\"The group index (group) is out of range.\")\n\t\t}\n\t}\n\tif (missing(xvector)) {\n\t\tstop(\"The vector (xvector) containing values for the x-axis is required.\")\n\t}\n\tif (missing(covariates)) {\n\t\tmeans <- mplus.get.group.dataset(file,'irt_data','mean')\n\t\tcovariates <- means[,group]\n\t} else {\n\t\tif (length(covariates) != num_fx) {\n\t\t\tcstr <- sprintf(\"The length of the covariates vector should be %d.\\nFound: %d\", num_fx, length(covariates))\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tlinks <- mplus.get.group.attribute(file,'categorical_data','link')\n\tshift <- 0.0\n\tfor (i in c(1:num_fx)) {\n\t\tif (i != fidx) {\n\t\t\tshift <- shift + covariates[i]*gh5$irt_data$loading[ridx,i,group]\n\t\t}\n\t}\n\n\tprob <- array(0,c(length(xvector)))\n\tfor (i in c(1:length(xvector))) {\n\t\tx <- xvector[i]\n\t\tif (cat == 1) {\n\t\t\tp <- gh5$irt_data$tau[cat,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n\t\t\tp <- p * gh5$irt_data$scale[ridx,group]\n\t\t\tprob[i] <- lin(p,links[ridx])\n\t\t} else if (cat == max_num_cat) {\n\t\t\tp = gh5$irt_data$tau[cat-1,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n\t\t\tp = p * gh5$irt_data$scale[ridx,group]\n\t\t\tprob[i] = 1.0 - lin(p,links[ridx])\n\t\t} else {\n\t\t\tp = gh5$irt_data$tau[cat,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n\t\t\tp = p * gh5$irt_data$scale[ridx,group]\n\n\t\t\tp2 = gh5$irt_data$tau[cat-1,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n\t\t\tp2 = p2 * gh5$irt_data$scale[ridx,group]\n\n\t\t\tprob[i] = lin(p,links[ridx]) - lin(p2,links[ridx])\n\t\t}\n\t}\n\n\tprob\n}\n\n\n#========================================================================\n# mplus.compute.irt.iic\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (required)\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (required)\n#\tuvar - the indicator variable, can be the variable index or the quoted variable name (required)\n#\txvector -> the vector containing x values to use (required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\n# eg. mplus.compute.irt.iic('ex7.27.gh5',1,'F','U1',seq(-3,3,0.2))\n#\nmplus.compute.irt.iic <- function(file,group,xvar,uvar,xvector,covariates) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if irt data exists\n\tif ( !(\"irt_data\" %in% names(gh5)) ) {\n\t\tstop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\t#\tproperties[1] - number of factors\n\t#\tproperties[2] - number of factors/covariates\n\t#\tproperties[3] - number of indicators\n\t#\tproperties[4] - number of classes\n\t#\tproperties[5] - maximum number of categories \n\tprops <- mplus.get.group.attribute(file,'irt_data','properties')\n\n\tnum_fx <- as.integer(props[2])\n\tnum_r <- as.integer(props[3])\n\tmax_num_cat <- as.integer(props[5])\n\n\tif (missing(xvar)) {\n\t\tstop(\"The x-axis variable (xvar) is required.\")\n\t} else {\n\t\tif (is.character(xvar)) {\n\t\t\tindex <- pmatch(xvar, flabels, nomatch=0)\n\t\t\tif (index == 0) {\n\t\t\t\tcstr <- sprintf(\"Unknown x-variable:  %s\\n\", xvar)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tfidx = index\n\t\t} else {\n\t\t\tif (xvar <= 0 || xvar > num_fx) {\n\t\t\t\tstop(\"The index for the x-variable (xvar) is out of range.\")\n\t\t\t}\n\t\t\tfidx = xvar\n\t\t}\n\t}\n\tif (missing(uvar)) {\n\t\tstop(\"The indicator variable (uvar) is required.\")\n\t} else {\n\t\tif (is.character(uvar)) {\n\t\t\tindex <- pmatch(uvar, ulabels, nomatch=0)\n\t\t\tif (index == 0) {\n\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tridx = index\n\t\t} else {\n\t\t\tif (uvar <= 0 || uvar > num_r) {\n\t\t\t\tstop(\"The index for the indicator (uvar) is out of range.\")\n\t\t\t}\n\t\t\tridx = uvar\n\t\t}\n\t}\n\tif (missing(group)) {\n\t\tstop(\"The group index (group) is required.\")\n\t} else {\n\t\tif (group <= 0 || group > props[4]) {\n\t\t\tstop(\"The group index (group) is out of range.\")\n\t\t}\n\t}\n\tif (missing(xvector)) {\n\t\tstop(\"The vector (xvector) containing values for the x-axis is required.\")\n\t}\n\tif (missing(covariates)) {\n\t\tcovariates <- mplus.get.group.dataset(file,'irt_data','mean')\n\t} else {\n\t\tif (length(covariates) != num_fx) {\n\t\t\tcstr <- sprintf(\"The length of the covariates vector should be %d.\\nFound: %d\", num_fx, length(covariates))\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tcategories <- mplus.get.group.attribute(file,'irt_data','categories')\n\tlinks <- mplus.get.group.attribute(file,'categorical_data','link')\n\n\tshift <- 0.0\n\tfor (i in c(1:num_fx)) {\n\t\tif (i != fidx) {\n\t\t\tshift <- shift + covariates[i]*gh5$irt_data$loading[ridx,i,group]\n\t\t}\n\t}\n\n\tcategories <- as.numeric(categories)\n\n\tprobvec <- array(0, c(length(xvector),categories[ridx]+1))\n\tfor (i in c(1:length(xvector))) {\n\t\tx <- xvector[i]\n\t\tprobvec[1] <- 0\n\t\tfor (j in c(2:c(categories[ridx]))) {\n\t\t\tfp = gh5$irt_data$tau[j-1,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n\t\t\tfp = fp * gh5$irt_data$scale[ridx,group]\n\t\t\tdp = lin(fp,links[ridx])\n\t\t\tprobvec[i,j] <- dp\n\t\t}\n\t\tprobvec[i,categories[ridx]+1]=1.0\n\t}\n\n\tprob <- array(0,c(length(xvector)))\n\tfor (i in c(1:length(xvector))) {\n\t\tx <- xvector[i]\n\t\tfor (j in c(2:c(categories[ridx]+1))) {\n\t\t\tr <- 10**(-10)\n\t\t\tep = probvec[i,j] - probvec[i,j-1]\n\t\t\tif (ep < r) { ep <- r }\n\t\t\tdp = gh5$irt_data$scale[ridx,group] * gh5$irt_data$loading[fidx,ridx,group] * gh5$irt_data$scale[ridx,group] * gh5$irt_data$loading[fidx,ridx,group];\n\t\t\tp = (probvec[i,j] * (1-probvec[i,j])) - (probvec[i,j-1] * (1-probvec[i,j-1]))\n\t\t\tprob[i] <- prob[i] + p * p * dp / ep\n\t\t}\n\t}\n\n\tprob\n}\n\n#========================================================================\n# mplus.plot.irt.icc\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (not required) -- 1 if not specified\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (not required, uses the first x)\n#\tuvar - the indicator variable or vector containing more than one indicator variable\n#\t\t - can be the variable index or the quoted variable name\n#\t\t - if not given, assume all indicator variables but cat must be given (not required)\n#\tcat - the category number\n#\t\t- if not given, assume all categories for the given indicator variables\n#\t\t- required if uvar not given\n#\tcat2 - the second category number if range of categories is desired (not required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\txrange - the type of range for the x-axis (not required)\n#\t\t- xrange=1: -1 s.d to +1 s.d of xvar\n#\t\t- xrange=2: -2 s.d to +2 s.d of xvar\n#\t\t- xrange=3: -3 s.d to +3 s.d of xvar (default)\n#\t\t- xrange=4: -4 s.d to +4 s.d of xvar\n#\t\t- xrange=5: -5 s.d to +5 s.d of xvar\n#\t\t- xrange=6: -6 s.d to +6 s.d of xvar\n#\txstep - the step increment for the x-axis range (not required)\n#\t\t- xstep=1: 1.0\n#\t\t- xstep=2: 0.5\n#\t\t- xstep=3: 0.1\n#\t\t- xstep=4: 0.05\n#\t\t- xstep=5: 1/2 s.d of xvar\n#\t\t- xstep=6: 1/4 s.d of xvar\n#\t\t- xstep=7: 1/5 s.d of xvar (default)\n#\t\t- xstep=8: 1/10 s.d of xvar\n#\t\t- xstep=9: 1/20 s.d of xvar\n#\t\t- xstep=10: 1/50 s.d of xvar\n#\t\t- xstep=11: 1/100 s.d of xvar\n#\n# eg. mplus.plot.irt.icc('ex7.27.gh5',1,'F','U1',)\n#\nmplus.plot.irt.icc <- function(file,group=1,xvar=1,uvar,cat,cat2,covariates,xrange=3,xstep=7,lloc=\"top\") {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if irt data exists\n\tif ( !(\"irt_data\" %in% names(gh5)) ) {\n\t\tstop(\"This function requires IRT data.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\t#\tproperties[1] - number of factors\n\t#\tproperties[2] - number of factors/covariates\n\t#\tproperties[3] - number of indicators\n\t#\tproperties[4] - number of classes\n\t#\tproperties[5] - maximum number of categories \n\tprops <- mplus.get.group.attribute(file,'irt_data','properties')\n\n\tflabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n\tflabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n\tulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n\tulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\n\tnum_fx <- as.integer(props[2])\n\tnum_r <- as.integer(props[3])\n\tmax_num_cat <- as.integer(props[5])\n\n\tif (is.character(xvar)) {\n\t\txvar <- toupper(xvar)\n\t\tindex <- pmatch(xvar, flabels, nomatch=0)\n\t\tif (index == 0) {\n\t\t\tcstr <- sprintf(\"Unknown variable for the x-axis:  %s\\n\", xvar)\n\t\t\tstop(cstr)\n\t\t}\n\t\tfidx = index\n\t} else {\n\t\tif (xvar <= 0 || xvar > num_fx) {\n\t\t\tstop(\"The index for the x-variable (xvar) is out of range.\")\n\t\t}\n\t\tfidx = xvar\n\t}\n\tif (missing(uvar)) {\n\t} else if (length(uvar) > 1) {\n\t\tridx <- vector()\n\t\tfor (r in c(1:length(uvar))) {\n\t\t\tvar <- uvar[r]\n\t\t\tif (is.character(var)) {\n\t\t\t\tvar <- toupper(var)\n\t\t\t\tindex <- pmatch(var, ulabels, nomatch=0)\n\t\t\t\tif (index == 0) {\n\t\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", var)\n\t\t\t\t\tstop(cstr)\n\t\t\t\t}\n\t\t\t\tridx[r] = index\n\t\t\t} else {\n\t\t\t\tif (var <= 0 || var > num_r) {\n\t\t\t\t\tstop(\"The index for the indicator in uvar is out of range.\")\n\t\t\t\t}\n\t\t\t\tridx[r] = var\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (is.character(uvar)) {\n\t\t\tuvar <- toupper(uvar)\n\t\t\tindex <- pmatch(uvar, ulabels, nomatch=0)\n\t\t\tif (index == 0) {\n\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tridx <- index\n\t\t} else {\n\t\t\tif (uvar <= 0 || uvar > num_r) {\n\t\t\t\tstop(\"The index for the indicator (uvar) is out of range.\")\n\t\t\t}\n\t\t\tridx <- uvar\n\t\t}\n\t}\n\tif (group <= 0 || group > props[4]) {\n\t\tstop(\"The group index (group) is out of range.\")\n\t}\n\tif (missing(covariates)) {\n\t\txmean <- mplus.get.group.dataset(file,'irt_data','mean')\n\t\tcovariates <- xmean[,group]\n\t} else {\n\t\tif (length(covariates) != num_fx) {\n\t\t\tcstr <- sprintf(\"The length of the covariates vector should be %d.\", num_fx)\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tcategories <- mplus.get.group.attribute(file,'irt_data','categories')\n\tif (missing(uvar)) {\n\t\t# case 1: uvar not specified, we plot ICC for all variables.  The category number must be given.\n\t\tif (missing(cat)) {\n\t\t\tstop(\"The category number (cat) is required when plotting ICCs for all variables.\")\n\t\t}\n\t\tfor (i in c(1:num_r)) {\n\t\t\tif (cat <= 0 || cat > categories[i]) {\n\t\t\t\tcstr <- sprintf(\"The category number (cat) is out of range for variable %s.\", ulabels[i])\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t}\n\t\tif (!(missing(cat2))) {\n\t\t\tif (cat > cat2) {\n\t\t\t\tcstr <- sprintf(\"The first category number (cat2=%d) must be smaller than the second category number (cat2=%d).\", cat, cat2)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tfor (i in c(1:num_r)) {\n\t\t\t\tif (cat2 <= 0 || cat2 > categories[i]) {\n\t\t\t\t\tcstr <- sprintf(\"The second category number (cat2) is out of range for variable %s.\", ulabels[i])\n\t\t\t\t\tstop(cstr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (length(uvar) > 1) {\n\t\tfor (r in c(1:length(ridx))) {\n\t\t\tif (!(missing(cat))) {\n\t\t\t\tif (cat <= 0 || cat > categories[ridx[r]]) {\n\t\t\t\t\tcstr <- sprintf(\"The category (cat) is out of range for variable %s.\", ulabels[ridx[r]])\n\t\t\t\t\tstop(cstr)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t# cat is missing but cat2 isn't!\n\t\t\t\tif (!(missing(cat2))) {\n\t\t\t\t\tstop(\"The first category (cat) is required if the second category (cat2) is given.\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(missing(cat2))) {\n\t\t\t\tif (cat2 <= 0 || cat2 > categories[ridx[r]]) {\n\t\t\t\t\tcstr <- sprintf(\"The category (cat2) is out of range for variable %s.\", ulabels[ridx[r]])\n\t\t\t\t\tstop(cstr)\n\t\t\t\t}\n\t\t\t\tif (cat > cat2) {\n\t\t\t\t\tcstr <- sprintf(\"The first category (cat2=%d) must be smaller than the second category (cat2=%d).\", cat, cat2)\n\t\t\t\t\tstop(cstr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!(missing(cat))) {\n\t\t\tif (cat <= 0 || cat > categories[ridx]) {\n\t\t\t\tcstr <- sprintf(\"The category (cat) is out of range for variable %s.\", ulabels[ridx])\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t} else {\n\t\t\t# cat is missing but cat2 isn't!\n\t\t\tif (!(missing(cat2))) {\n\t\t\t\tstop(\"The first category (cat) is required if the second category (cat2) is given.\")\n\t\t\t}\n\t\t}\n\t\tif (!(missing(cat2))) {\n\t\t\tif (cat2 <= 0 || cat2 > categories[ridx]) {\n\t\t\t\tcstr <- sprintf(\"The category (cat2) is out of range for variable %s.\", ulabels[ridx])\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tif (cat > cat2) {\n\t\t\t\tcstr <- sprintf(\"The first category (cat2=%d) must be smaller than the second category (cat2=%d).\", cat, cat2)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t}\n\t}\n\tif (!(missing(xrange))) {\n\t\tif (xrange <= 0 || xrange > 6) {\n\t\t\tstop(\"The xrange type should be between 1 and 6.\")\n\t\t}\n\t}\n\tif (!(missing(xstep))) {\n\t\tif (xstep <= 0 || xstep > 11) {\n\t\t\tstop(\"The xstep type should be between 1 and 11.\")\n\t\t}\n\t}\n\n\tvariances <- mplus.get.group.dataset(file,'irt_data','variance')\n\tmeans <- mplus.get.group.dataset(file,'irt_data','mean')\n\tfsd = sqrt(variances[fidx])\n\n\txmult <- switch(xrange, 1, 2, 3, 4, 5, 6)\n\tvmin = means[fidx] + (-1) * xmult * fsd\n\tvmax = means[fidx] + xmult * fsd\n\n\tvstep = switch(xstep, 1.0, 0.5, 0.1, 0.05, 0.5*fsd, 0.25*fsd, 0.2*fsd, 0.1*fsd, 0.05*fsd, 0.02*fsd, 0.01*fsd)\n\tsteps <- seq(vmin,vmax,by=vstep)\n\n    print(steps)\n\n\t# if cat is missing, then we plot all categories\n\tif (missing(uvar)) {\n\t\tprob <- array(0,c(num_r,length(steps)))\n\t\txx <- array(0,c(num_r,length(steps)))\n\t\tif (missing(cat2)) {\n\t\t\tfor (r in c(1:num_r)) {\n\t\t\t\tprob[r,] <- mplus.compute.irt.icc(file,group,fidx,r,cat,xvector=steps,covariates=covariates)\n\t\t\t\txx[r,] <- steps\n\t\t\t}\n\t\t} else {\n\t\t\tfor (r in c(1:num_r)) {\n\t\t\t\tfor (c in c(cat:cat2)) {\n\t\t\t\t\tprob[r,] <- prob[r,] + mplus.compute.irt.icc(file,group,fidx,r,c,xvector=steps,covariates=covariates)\n\t\t\t\t}\n\t\t\t\txx[r,] <- steps\n\t\t\t}\n\t\t}\n\n\t\t# plot the icc\n\t\tcstr <- sprintf(\"Item characteristic curves as a function of %s, Class %d\", flabels[fidx], group)\n\t\tcolors <- rainbow(num_r)\n\t\tplot(xx,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n')\n\t\tfor (i in c(1:num_r)) {\n\t\t\tlines(xx[i,],prob[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(num_r))\n\t\tlty <- array(0,c(num_r))\n\t\tlwd <- array(0,c(num_r))\n\t\tfor (i in c(1:num_r)) {\n\t\t\tif (missing(cat2)) {\n\t\t\t\tldesc[i] <- sprintf(\"%s, Category %d\", ulabels[i], cat)\n\t\t\t} else {\n\t\t\t\tldesc[i] <- sprintf(\"%s, Cat %d to %d\", ulabels[i], cat, cat2)\n\t\t\t}\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else if (length(ridx) > 1) {\n\t\tprob <- array(0,c(length(ridx),length(steps)))\n\t\txx <- array(0,c(length(ridx),length(steps)))\n\t\tif (missing(cat)) {\n\t\t\tfor (j in c(1:categories[ridx])) {\n\t\t\t\tprob[j,] <- mplus.compute.irt.icc(file,group,fidx,ridx,j,xvector=steps,covariates=covariates)\n\t\t\t\txx[j,] <- steps\n\t\t\t}\n\t\t} else if (missing(cat2)) {\n\t\t\tfor (r in c(1:length(ridx))) {\n\t\t\t\tprob[r,] <- mplus.compute.irt.icc(file,group,fidx,ridx[r],cat,xvector=steps,covariates=covariates)\n\t\t\t\txx[r,] <- steps\n\t\t\t}\n\t\t} else {\n\t\t\tfor (r in c(1:length(ridx))) {\n\t\t\t\tfor (c in c(cat:cat2)) {\n\t\t\t\t\tprob[r,] <- prob[r,] + mplus.compute.irt.icc(file,group,fidx,ridx[r],c,xvector=steps,covariates=covariates)\n\t\t\t\t}\n\t\t\t\txx[r,] <- steps\n\t\t\t}\n\t\t}\n\n\t\t# plot the icc\n\t\tcstr <- sprintf(\"Item characteristic curves as a function of %s, Class %d\", flabels[fidx], group)\n\t\tcolors <- rainbow(length(ridx))\n\t\tplot(xx,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n')\n\t\tfor (i in c(1:length(ridx))) {\n\t\t\tlines(xx[i,],prob[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(length(ridx)))\n\t\tlty <- array(0,c(length(ridx)))\n\t\tlwd <- array(0,c(length(ridx)))\n\t\tfor (i in c(1:length(ridx))) {\n\t\t\tif (missing(cat2)) {\n\t\t\t\tldesc[i] <- sprintf(\"%s, Category %d\", ulabels[ridx[i]], cat)\n\t\t\t} else {\n\t\t\t\tldesc[i] <- sprintf(\"%s, Cat %d to %d\", ulabels[ridx[i]], cat, cat2)\n\t\t\t}\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else if (missing(cat)) {\n\t\tprob <- array(0,c(categories[ridx],length(steps)))\n\t\txx <- array(0,c(categories[ridx],length(steps)))\n\t\tfor (j in c(1:categories[ridx])) {\n\t\t\tprob[j,] <- mplus.compute.irt.icc(file,group,fidx,ridx,j,steps,covariates)\n\t\t\txx[j,] <- steps\n\t\t}\n\n\t\t# plot the icc\n\t\tcstr <- sprintf(\"Item characteristic curve for %s (all categories)\\n as a function of %s, Class %d\", ulabels[ridx], flabels[fidx], group)\n\t\tcolors <- rainbow(categories[ridx])\n\t\tplot(xx,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tfor (i in c(1:categories[ridx])) {\n\t\t\tlines(xx[i,],prob[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- vector()\n\t\tfor (i in c(1:categories[ridx])) {\n\t\t\tldesc[i] <- sprintf(\"%s, Category %d\", ulabels[ridx], i)\n\t\t}\n\n\t\tlegend(lloc,ldesc,col=colors,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n\t} else if (missing(cat2)) {\n\t\t# if cat2 is missing, then we plot only the given category\n\n\t\tprob <- mplus.compute.irt.icc(file,group,fidx,ridx,cat,steps,covariates)\n\n\t\t# plot the icc\n\t\tcstr <- sprintf(\"Item characteristic curve for %s (category %d)\\n as a function of %s, Class %d\", ulabels[ridx], cat, flabels[fidx], group)\n\t\tplot(steps,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(steps,prob,col='red')\n\t} else {\n\t\t# if cat and cat2 are given, then we plot the sum from cat to cat2\n\n\t\tprob <- array(0,c(length(steps)))\n\t\tfor (c in c(cat:cat2)) {\n\t\t\tprob <- prob + mplus.compute.irt.icc(file,group,fidx,ridx,c,steps,covariates)\n\t\t}\n\n\t\t# plot the icc\n\t\tcstr <- sprintf(\"Item characteristic curve for %s\\n(sum from category %d to category %d)\\nas a function of %s, Class %d\", ulabels[ridx], cat, cat2, flabels[fidx], group)\n\n\t\tplot(steps,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(steps,prob,col='red')\n\t}\n\n    steps\n}\n\n\n#========================================================================\n# mplus.plot.irt.iic\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (not required)\n#\t\t - if not given, group=1 will be used\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (not required, uses the first x)\n#\tuvar - the indicator variable or vector containing more than one indicator variable\n#\t\t - can be the variable index or the quoted variable name\n#\t\t - if not given, assume all indicator variables (not required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\txrange - the type of range for the x-axis (not required)\n#\t\t- xrange=1: -1 s.d to +1 s.d of xvar\n#\t\t- xrange=2: -2 s.d to +2 s.d of xvar\n#\t\t- xrange=3: -3 s.d to +3 s.d of xvar (default)\n#\t\t- xrange=4: -4 s.d to +4 s.d of xvar\n#\t\t- xrange=5: -5 s.d to +5 s.d of xvar\n#\t\t- xrange=6: -6 s.d to +6 s.d of xvar\n#\txstep - the step increment for the x-axis range (not required)\n#\t\t- xstep=1: 1.0\n#\t\t- xstep=2: 0.5\n#\t\t- xstep=3: 0.1\n#\t\t- xstep=4: 0.05\n#\t\t- xstep=5: 1/2 s.d of xvar\n#\t\t- xstep=6: 1/4 s.d of xvar\n#\t\t- xstep=7: 1/5 s.d of xvar (default)\n#\t\t- xstep=8: 1/10 s.d of xvar\n#\t\t- xstep=9: 1/20 s.d of xvar\n#\t\t- xstep=10: 1/50 s.d of xvar\n#\t\t- xstep=11: 1/100 s.d of xvar\n#\n# eg. mplus.plot.irt.iic('ex7.27.gh5',1,'F','U1',)\n#\nmplus.plot.irt.iic <- function(file,group=1,xvar=1,uvar,covariates,xrange=3,xstep=7,lloc=\"top\") {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if irt data exists\n\tif ( !(\"irt_data\" %in% names(gh5)) ) {\n\t\tstop(\"This function requires IRT data.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\t#\tproperties[1] - number of factors\n\t#\tproperties[2] - number of factors/covariates\n\t#\tproperties[3] - number of indicators\n\t#\tproperties[4] - number of classes\n\t#\tproperties[5] - maximum number of categories \n\tprops <- mplus.get.group.attribute(file,'irt_data','properties')\n\n\tflabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n\tflabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n\tflabels <- tolower(flabels)\n\tulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n\tulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\tulabels <- tolower(ulabels)\n\n\tnum_fx <- as.integer(props[2])\n\tnum_r <- as.integer(props[3])\n\tmax_num_cat <- as.integer(props[5])\n\n\tif (is.character(xvar)) {\n\t\txvar <- tolower(xvar)\n\t\tindex <- pmatch(xvar, flabels, nomatch=0)\n\t\tif (index == 0) {\n\t\t\tcstr <- sprintf(\"Unknown variable for the x-axis:  %s\\n\", xvar)\n\t\t\tstop(cstr)\n\t\t}\n\t\tfidx = index\n\t} else {\n\t\tif (xvar <= 0 || xvar > num_fx) {\n\t\t\tstop(\"The index for the x-variable (xvar) is out of range.\")\n\t\t}\n\t\tfidx = xvar\n\t}\n\tif (missing(uvar)) {\n\t} else if (length(uvar) > 1) {\n\t\tridx <- vector()\n\t\tfor (r in c(1:length(uvar))) {\n\t\t\tvar <- uvar[r]\n\t\t\tif (is.character(var)) {\n\t\t\t\tindex <- pmatch(var, ulabels, nomatch=0)\n\t\t\t\tif (index == 0) {\n\t\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", var)\n\t\t\t\t\tstop(cstr)\n\t\t\t\t}\n\t\t\t\tridx[r] = index\n\t\t\t} else {\n\t\t\t\tif (var <= 0 || var > num_r) {\n\t\t\t\t\tstop(\"The index for the indicator in uvar is out of range.\")\n\t\t\t\t}\n\t\t\t\tridx[r] = var\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (is.character(uvar)) {\n\t\t\tuvar <- tolower(uvar)\n\t\t\tindex <- pmatch(uvar, ulabels, nomatch=0)\n\t\t\tif (index == 0) {\n\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tridx = index\n\t\t} else {\n\t\t\tif (uvar <= 0 || uvar > num_r) {\n\t\t\t\tstop(\"The index for the indicator (uvar) is out of range.\")\n\t\t\t}\n\t\t\tridx = uvar\n\t\t}\n\t}\n\tif (group <= 0 || group > props[4]) {\n\t\tstop(\"The group index (group) is out of range.\")\n\t}\n\tif (missing(covariates)) {\n\t\txmean <- mplus.get.group.dataset(file,'irt_data','mean')\n\t\tcovariates <- xmean[,group]\n\t} else {\n\t\tif (length(covariates) != num_fx) {\n\t\t\tcstr <- sprintf(\"The length of the covariates vector should be %d.\", num_fx)\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tcategories <- mplus.get.group.attribute(file,'irt_data','categories')\n\tif (!(missing(xrange))) {\n\t\tif (xrange <= 0 || xrange > 6) {\n\t\t\tstop(\"The xrange type should be between 1 and 6.\")\n\t\t}\n\t}\n\tif (!(missing(xstep))) {\n\t\tif (xstep <= 0 || xstep > 11) {\n\t\t\tstop(\"The xstep type should be between 1 and 11.\")\n\t\t}\n\t}\n\n\tvariances <- mplus.get.group.dataset(file,'irt_data','variance')\n\tmeans <- mplus.get.group.dataset(file,'irt_data','mean')\n\tfsd = sqrt(variances[fidx])\n\n\txmult <- switch(xrange, 1, 2, 3, 4, 5, 6)\n\tvmin = means[fidx] + (-1) * xmult * fsd\n\tvmax = means[fidx] + xmult * fsd\n\n\tvstep = switch(xstep, 1.0, 0.5, 0.1, 0.05, 0.5*fsd, 0.25*fsd, 0.2*fsd, 0.1*fsd, 0.05*fsd, 0.02*fsd, 0.01*fsd)\n\tsteps <- seq(vmin,vmax,by=vstep)\n\n\t# if cat is missing, then we plot all categories\n\tif (missing(uvar)) {\n\t\tprob <- array(0,c(num_r,length(steps)))\n\t\txx <- array(0,c(num_r,length(steps)))\n\t\tfor (r in c(1:num_r)) {\n\t\t\tprob[r,] <- mplus.compute.irt.iic(file,group,fidx,r,xvector=steps,covariates=covariates)\n\t\t\txx[r,] <- steps\n\t\t}\n\n\t\t# plot the iic\n\t\tcstr <- sprintf(\"Item information curves as a function of %s, Class %d\", flabels[fidx], group)\n\t\tcolors <- rainbow(num_r)\n\t\tplot(xx,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n\t\tfor (i in c(1:num_r)) {\n\t\t\tlines(xx[i,],prob[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(num_r))\n\t\tlty <- array(0,c(num_r))\n\t\tlwd <- array(0,c(num_r))\n\t\tfor (i in c(1:num_r)) {\n\t\t\tldesc[i] <- sprintf(\"%s\", ulabels[i])\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else if (length(ridx) > 1) {\n\t\tprob <- array(0,c(length(ridx),length(steps)))\n\t\txx <- array(0,c(length(ridx),length(steps)))\n\t\tfor (r in c(1:length(ridx))) {\n\t\t\tprob[r,] <- mplus.compute.irt.iic(file,group,fidx,ridx[r],xvector=steps,covariates=covariates)\n\t\t\txx[r,] <- steps\n\t\t}\n\n\t\t# plot the iic\n\t\tcstr <- sprintf(\"Item information curves as a function of %s, Class %d\", flabels[fidx], group)\n\t\tcolors <- rainbow(length(ridx))\n\t\tplot(xx,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n\t\tfor (i in c(1:length(ridx))) {\n\t\t\tlines(xx[i,],prob[i,],col=colors[i])\n\t\t}\n\n#\t\tfor (i in c(1:length(steps))) {\n#\t\t\tcstr <- sprintf(\"x = %0.3f, probx = %0.3f\", xx[1,i], prob[1,i])\n#\t\t\tprint(cstr)\n#\t\t}\n\n\t\tldesc <- array(0,c(length(ridx)))\n\t\tlty <- array(0,c(length(ridx)))\n\t\tlwd <- array(0,c(length(ridx)))\n\t\tfor (i in c(1:length(ridx))) {\n\t\t\tldesc[i] <- sprintf(\"%s\", ulabels[ridx[i]])\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tprob <- mplus.compute.irt.iic(file,group,fidx,ridx,steps,covariates)\n\n#\t\tfor (i in c(1:length(steps))) {\n#\t\t\tcstr <- sprintf(\"x = %0.3f, probx = %0.3f\", steps[i], prob[i])\n#\t\t\tprint(cstr)\n#\t\t}\n\n\t\t# plot the iic\n\t\tcstr <- sprintf(\"Item information curve for %s as a function of %s, Class %d\", ulabels[ridx], flabels[fidx], group)\n\t\tplot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n\t\tlines(steps,prob,col='red')\n\t}\n}\n\n\n#========================================================================\n# mplus.plot.irt.tic\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (not required)\n#\t\t - if not given, group=1 will be shown\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (not required, uses the first x)\n#\tuvar - the indicator variable or vector containing more than one indicator variable\n#\t\t - can be the variable index or the quoted variable name\n#\t\t - if not given, assume all indicator variables (not required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\txrange - the type of range for the x-axis (not required)\n#\t\t- xrange=1: -1 s.d to +1 s.d of xvar\n#\t\t- xrange=2: -2 s.d to +2 s.d of xvar\n#\t\t- xrange=3: -3 s.d to +3 s.d of xvar (default)\n#\t\t- xrange=4: -4 s.d to +4 s.d of xvar\n#\t\t- xrange=5: -5 s.d to +5 s.d of xvar\n#\t\t- xrange=6: -6 s.d to +6 s.d of xvar\n#\txstep - the step increment for the x-axis range (not required)\n#\t\t- xstep=1: 1.0\n#\t\t- xstep=2: 0.5\n#\t\t- xstep=3: 0.1\n#\t\t- xstep=4: 0.05\n#\t\t- xstep=5: 1/2 s.d of xvar\n#\t\t- xstep=6: 1/4 s.d of xvar\n#\t\t- xstep=7: 1/5 s.d of xvar (default)\n#\t\t- xstep=8: 1/10 s.d of xvar\n#\t\t- xstep=9: 1/20 s.d of xvar\n#\t\t- xstep=10: 1/50 s.d of xvar\n#\t\t- xstep=11: 1/100 s.d of xvar\n#\n# eg. mplus.plot.irt.tic('ex7.27.gh5',1,'F','U1',)\n#\nmplus.plot.irt.tic <- function(file,group=1,xvar=1,uvar,covariates,xrange=3,xstep=7) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if irt data exists\n\tif ( !(\"irt_data\" %in% names(gh5)) ) {\n\t\tstop(\"This function requires IRT data.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\t#\tproperties[1] - number of factors\n\t#\tproperties[2] - number of factors/covariates\n\t#\tproperties[3] - number of indicators\n\t#\tproperties[4] - number of classes\n\t#\tproperties[5] - maximum number of categories \n\tprops <- mplus.get.group.attribute(file,'irt_data','properties')\n\n\tflabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n\tflabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n\tflabels <- tolower(flabels)\n\tulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n\tulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\tulabels <- tolower(ulabels)\n\n\tnum_fx <- as.integer(props[2])\n\tnum_r <- as.integer(props[3])\n\tmax_num_cat <- as.integer(props[5])\n\n\tif (is.character(xvar)) {\n\t\tindex <- pmatch(xvar, flabels, nomatch=0)\n\t\tif (index == 0) {\n\t\t\tcstr <- sprintf(\"Unknown variable for the x-axis:  %s\\n\", xvar)\n\t\t\tstop(cstr)\n\t\t}\n\t\tfidx = index\n\t} else {\n\t\tif (xvar <= 0 || xvar > num_fx) {\n\t\t\tstop(\"The index for the x-variable (xvar) is out of range.\")\n\t\t}\n\t\tfidx = xvar\n\t}\n\tif (missing(uvar)) {\n\t} else if (length(uvar) > 1) {\n\t\tridx <- vector()\n\t\tfor (r in c(1:length(uvar))) {\n\t\t\tvar <- uvar[r]\n\t\t\tif (is.character(var)) {\n\t\t\t\tindex <- pmatch(var, ulabels, nomatch=0)\n\t\t\t\tif (index == 0) {\n\t\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", var)\n\t\t\t\t\tstop(cstr)\n\t\t\t\t}\n\t\t\t\tridx[r] = index\n\t\t\t} else {\n\t\t\t\tif (var <= 0 || var > num_r) {\n\t\t\t\t\tstop(\"The index for the indicator in uvar is out of range.\")\n\t\t\t\t}\n\t\t\t\tridx[r] = var\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (is.character(uvar)) {\n\t\t\tindex <- pmatch(uvar, ulabels, nomatch=0)\n\t\t\tif (index == 0) {\n\t\t\t\tcstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n\t\t\t\tstop(cstr)\n\t\t\t}\n\t\t\tridx = index\n\t\t} else {\n\t\t\tif (uvar <= 0 || uvar > num_r) {\n\t\t\t\tstop(\"The index for the indicator (uvar) is out of range.\")\n\t\t\t}\n\t\t\tridx = uvar\n\t\t}\n\t}\n\tif (group <= 0 || group > props[4]) {\n\t\tstop(\"The group index (group) is out of range.\")\n\t}\n\tif (missing(covariates)) {\n\t\txmean <- mplus.get.group.dataset(file,'irt_data','mean')\n\t\tcovariates <- xmean[,group]\n\t} else {\n\t\tif (length(covariates) != num_fx) {\n\t\t\tcstr <- sprintf(\"The length of the covariates vector should be %d.\", num_fx)\n\t\t\tstop(cstr)\n\t\t}\n\t}\n\n\tcategories <- mplus.get.group.attribute(file,'irt_data','categories')\n\tif (!(missing(xrange))) {\n\t\tif (xrange <= 0 || xrange > 6) {\n\t\t\tstop(\"The xrange type should be between 1 and 6.\")\n\t\t}\n\t}\n\tif (!(missing(xstep))) {\n\t\tif (xstep <= 0 || xstep > 11) {\n\t\t\tstop(\"The xstep type should be between 1 and 11.\")\n\t\t}\n\t}\n\n\tvariances <- mplus.get.group.dataset(file,'irt_data','variance')\n\tmeans <- mplus.get.group.dataset(file,'irt_data','mean')\n\tfsd = sqrt(variances[fidx])\n\n\txmult <- switch(xrange, 1, 2, 3, 4, 5, 6)\n\tvmin = means[fidx] + (-1) * xmult * fsd\n\tvmax = means[fidx] + xmult * fsd\n\n\tvstep = switch(xstep, 1.0, 0.5, 0.1, 0.05, 0.5*fsd, 0.25*fsd, 0.2*fsd, 0.1*fsd, 0.05*fsd, 0.02*fsd, 0.01*fsd)\n\tsteps <- seq(vmin,vmax,by=vstep)\n\n\t# if cat is missing, then we plot all categories\n\tif (missing(uvar)) {\n\t\tprob <- array(0,c(length(steps)))\n\t\tfor (r in c(1:num_r)) {\n\t\t\tprob <- prob + mplus.compute.irt.iic(file,group,fidx,r,xvector=steps,covariates=covariates)\n\t\t}\n        prob <- prob + 1 / gh5$irt_data$variance[fidx,group]\n\t\t# plot the tic\n\t\tcstr <- sprintf(\"Total information curve as a function of %s, Class %d\", flabels[fidx], group)\n\t\tplot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n\t\tlines(steps,prob,col='red')\n\t} else if (length(ridx) > 1) {\n\t\tprob <- array(0,c(length(steps)))\n\t\tfor (r in c(1:length(ridx))) {\n\t\t\tprob <- prob + mplus.compute.irt.iic(file,group,fidx,ridx[r],xvector=steps,covariates=covariates)\n\t\t}\n\n\t\t# plot the iic\n\t\tcstr <- sprintf(\"Partial total information curve as a function of %s, Class %d\", flabels[fidx], group)\n\t\tplot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n\t\tlines(steps,prob,col='red')\n\t} else {\n\t\tprob <- mplus.compute.irt.iic(file,group,fidx,ridx,steps,covariates)\n\n\t\t# plot the tic\n\t\tcstr <- sprintf(\"Partial total information curve as a function of %s, Class %d\", flabels[fidx], group)\n\t\tplot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n\t\tlines(steps,prob,col='red')\n\t}\n\n#\tfor (i in c(1:length(steps))) {\n#\t\tcstr <- sprintf(\"x = %0.3f, probx = %0.5f\", steps[i], prob[i])\n#\t\tprint(cstr)\n#\t}\n}\n\n\n\n######################################################################################################\n# Functions for Survival plots\n######################################################################################################\n\n#========================================================================\n# mplus.list.survival.variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.survival.variables('ex6.21.gh5')\n#\nmplus.list.survival.variables <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n#\tcat(c(\"\\nList of variables to use in the following functions:\\n\"))\n#\tcat(c(\" - mplus.compute.irt.icc\\n\"))\n#\tcat(c(\" - mplus.plot.irt.icc\\n\"))\n\n\tcat(c(\"\\nList of survival variables:\\n\"))\n\n\tfor (i in c(1:props[1])) {\n\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\tcstr <- sprintf(\"%s\", label)\n\t\tcstr <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", cstr, perl=TRUE)\n\t\tprint(cstr)\n\t}\n}\n\n\n#========================================================================\n# mplus.get.survival.kaplanmeier.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.survival.kaplanmeier.values('ex6.21.gh5','T')\n#\nmplus.get.survival.kaplanmeier.values <- function(file,survvar,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tif (missing(classnum)) {\n\t\tdatastr <- sprintf(\"kaplan_meier1\")\n\t} else {\n\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\tdims <- attr(classes,'dim')\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\t\tdatastr <- sprintf(\"kaplan_meier%d\", classnum)\n\t}\n\tkmvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\tif (missing(time)) {\n\t\treturn(kmvals[,2])\n\t} else {\n\t\treturn(kmvals[,1])\n\t}\n}\n\n\n\n#========================================================================\n# mplus.compute.survival.sample.logcumulative.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.compute.survival.sample.logcumulative.values('ex6.21.gh5','T')\n#\nmplus.compute.survival.sample.logcumulative.values <- function(file,survvar,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tif (missing(classnum)) {\n\t\tdatastr <- sprintf(\"kaplan_meier1\")\n\t} else {\n\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\tdims <- attr(classes,'dim')\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\t\tdatastr <- sprintf(\"kaplan_meier%d\", classnum)\n\t}\n\tkmvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\ty <- log(-log(kmvals[,2]))\n\treturn(y)\n}\n\n\n#========================================================================\n# mplus.get.survival.baseline.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tsurvvar2 - ending survival variable for getting sequential time\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.survival.baseline.values('ex6.21.gh5','T')\n#\nmplus.get.survival.baseline.values <- function(file,survvar,survvar2,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tif (!(missing(survvar2))) {\n\t\tif (is.character(survvar2)) {\n\t\t\tsurv_idx2 <- 0\n\t\t\tfor (i in c(1:props[1])) {\n\t\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\t\tif (label == survvar2) {\n\t\t\t\t\tsurv_idx2 = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (surv_idx2 == 0) {\n\t\t\t\tstop(\"- unknown survival variable:  \", survvar2)\n\t\t\t}\n\t\t} else {\n\t\t\tif (survvar2 <= 0 || survvar2 > props[1]) {\n\t\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t\t}\n\t\t\tsurv_idx2 = survvar2\n\t\t}\n\t}\n\n\tif (missing(survvar2)) {\n\t\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\t\tif (missing(classnum)) {\n\t\t\tdatastr <- sprintf(\"estimated_survival\")\n\t\t} else {\n\t\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\t\tdims <- attr(classes,'dim')\n\t\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\t\tstop(\"Class number is out of range.\")\n\t\t\t}\n\t\t\tdatastr <- sprintf(\"estimated_survival%d\", classnum)\n\t\t}\n\t\tesvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\t\tif (missing(time)) {\n\t\t\treturn(esvals[,2])\n\t\t} else {\n\t\t\treturn(esvals[,1])\n\t\t}\n\t} else {\n\t\t# ending survival variable given so we need to link them sequentially\n\t\tylast <- 1\n\t\txlast <- 0\n\t\tdata <- vector()\n\t\ttime <- vector()\n\t\tcount <- 0\n\t\tfor (s in c(surv_idx:surv_idx2)) {\n\t\t\tgroupstr <- sprintf(\"survival_data/survival%d\", s)\n\t\t\tif (missing(classnum)) {\n\t\t\t\tdatastr <- sprintf(\"estimated_survival\")\n\t\t\t} else {\n\t\t\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\t\t\tdims <- attr(classes,'dim')\n\t\t\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\t\t\tstop(\"Class number is out of range.\")\n\t\t\t\t}\n\t\t\t\tdatastr <- sprintf(\"estimated_survival%d\", classnum)\n\t\t\t}\n\t\t\tesvals1 <- mplus.get.group.dataset(file,groupstr,datastr)\n\t\t\t\n\t\t\tif (s == surv_idx) {\n\t\t\t\tcount <- length(esvals1[,1])\n\t\t\t\tdata[1:count] <- esvals1[,1]\n\t\t\t\ttime[1:count] <- estvals[,2]\n\t\t\t} else {\n\t\t\t\tn <- length(estvals1[,1])\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n#========================================================================\n# mplus.compute.survival.estimated.logcumulative.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.compute.survival.estimated.logcumulative.values('ex6.21.gh5','T')\n#\nmplus.compute.survival.estimated.logcumulative.values <- function(file,survvar,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tif (missing(classnum)) {\n\t\tdatastr <- sprintf(\"estimated_survival1\")\n\t} else {\n\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\tdims <- attr(classes,'dim')\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\t\tdatastr <- sprintf(\"estimated_survival%d\", classnum)\n\t}\n\tesvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\ty <- log(-log(esvals[,2]))\n\treturn(y)\n}\n\n\n\n#========================================================================\n# mplus.get.survival.basehazard.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.survival.basehazard.values('ex6.21.gh5','T')\n#\nmplus.get.survival.basehazard.values <- function(file,survvar,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tif (missing(classnum)) {\n\t\tdatastr <- sprintf(\"basehazard\")\n\t} else {\n\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\tdims <- attr(classes,'dim')\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\t\tdatastr <- sprintf(\"basehazard%d\", classnum)\n\t}\n\tbhvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\tif (missing(time)) {\n\t\treturn(bhvals[,2])\n\t} else {\n\t\treturn(bhvals[,1])\n\t}\n}\n\n\n#========================================================================\n# mplus.plot.survival.kaplanmeier\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.kaplanmeier('ex6.21.gh5','T')\n#\nmplus.plot.survival.kaplanmeier <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Kaplan-Meier curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tnpoints[i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(dims[1],maxpoints))\n\t\tyall <- array(NA, c(dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[i,1:npoints[i]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tyall[i,1:npoints[i]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(dims[1])\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(dims[1]))\n\t\tlty <- array(0,c(dims[1]))\n\t\tlwd <- array(0,c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"- class number is out of range\")\n\t\t}\n\n\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tyy <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n\t\tplot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(xx,yy,col='red')\n\t}\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.baseline('ex6.21.gh5','T')\n#\nmplus.plot.survival.baseline <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Estimated baseline survival curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tnpoints[i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(dims[1],maxpoints))\n\t\tyall <- array(NA, c(dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[i,1:npoints[i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tyall[i,1:npoints[i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(dims[1])\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(dims[1]))\n\t\tlty <- array(0,c(dims[1]))\n\t\tlwd <- array(0,c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tyy <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n\t\tplot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(xx,yy,col='red')\n\t}\n}\n\n\n#========================================================================\n# mplus.plot.survival.basehazard\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.basehazard('ex6.21.gh5','T')\n#\nmplus.plot.survival.basehazard <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required.\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Estimated baseline hazard curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.survival.basehazard.values(file,surv_idx,i,0)\n\t\t\tnpoints[i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(dims[1],maxpoints))\n\t\tyall <- array(NA, c(dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[i,1:npoints[i]] <- mplus.get.survival.basehazard.values(file,surv_idx,i,0)\n\t\t\tyall[i,1:npoints[i]] <- mplus.get.survival.basehazard.values(file,surv_idx,i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"\",main=cstr,type='n')\n\n\t\tcolors <- rainbow(dims[1])\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(dims[1]))\n\t\tlty <- array(0,c(dims[1]))\n\t\tlwd <- array(0,c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\txx <- mplus.get.survival.basehazard.values(file,surv_idx,classnum,0)\n\t\tyy <- mplus.get.survival.basehazard.values(file,surv_idx,classnum)\n\n\t\tplot(xx,yy,xlab=\"Time\",ylab=\"\",main=cstr,type='n')\n\t\tlines(xx,yy,col='red')\n\t}\n}\n\n\n#========================================================================\n# mplus.plot.survival.sample.logcumulative\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.sample.logcumulative('ex6.21.gh5','T')\n#\nmplus.plot.survival.sample.logcumulative <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Sample log cumulative hazard curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tnpoints[i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(dims[1],maxpoints))\n\t\tyall <- array(NA, c(dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[i,1:npoints[i]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tyall[i,1:npoints[i]] <- mplus.compute.survival.sample.logcumulative.values(file,surv_idx,i)\n\t\t\tfor (j in c(1:npoints[i])) {\n\t\t\t\tif (is.infinite(yall[j])) {\n\t\t\t\t\txall[j] = NA\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(dims[1])\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(dims[1]))\n\t\tlty <- array(0,c(dims[1]))\n\t\tlwd <- array(0,c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tyy <- mplus.compute.survival.sample.logcumulative.values(file,surv_idx,classnum)\n\t\tfor (j in c(1:length(xx))) {\n\t\t\tif (is.infinite(yy[j])) {\n\t\t\t\txx[j] = NA\n\t\t\t}\n\t\t}\n\n\t\tplot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(xx,yy,col='red')\n\t}\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.estimated.logcumulative\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.estimated.logcumulative('ex6.21.gh5','T')\n#\nmplus.plot.survival.estimated.logcumulative <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Estimated log cumulative hazard curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tnpoints[i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(dims[1],maxpoints))\n\t\tyall <- array(NA, c(dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[i,1:npoints[i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tyall[i,1:npoints[i]] <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,i)\n\t\t\tfor (j in c(1:npoints[i])) {\n\t\t\t\tif (is.infinite(yall[j])) {\n\t\t\t\t\txall[j] = NA\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(dims[1])\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(dims[1]))\n\t\tlty <- array(0,c(dims[1]))\n\t\tlwd <- array(0,c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tyy <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,classnum)\n\t\tfor (j in c(1:length(xx))) {\n\t\t\tif (is.infinite(yy[j])) {\n\t\t\t\txx[j] = NA\n\t\t\t}\n\t\t}\n\n\t\tplot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(xx,yy,col='red')\n\t}\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.kaplanmeier.vs.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.kaplanmeier.vs.baseline('ex6.21.gh5','T')\n#\nmplus.plot.survival.kaplanmeier.vs.baseline <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Kaplan-Meier curve compared with\\nestimated baseline survival curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(2*dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tnpoints[2*(i-1)+1] = length(xx)\n\t\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tnpoints[2*i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(2*dims[1],maxpoints))\n\t\tyall <- array(NA, c(2*dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tyall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i)\n\n\t\t\txall[2*i,1:npoints[2*i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tyall[2*i,1:npoints[2*i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(2*dims[1])\n\t\tfor (i in c(1:(2*dims[1]))) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(2*dims[1]))\n\t\tlty <- array(0,c(2*dims[1]))\n\t\tlwd <- array(0,c(2*dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[2*(i-1)+1] <- sprintf(\"KM for Class %d\", i)\n\t\t\tlty[2*(i-1)+1] = 1\n\t\t\tlwd[2*(i-1)+1] = 2.5\n\n\t\t\tldesc[2*i] <- sprintf(\"ES for Class %d\", i)\n\t\t\tlty[2*i] = 1\n\t\t\tlwd[2*i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\tnpoints <- array(0, c(2))\n\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tnpoints[1] = length(xx)\n\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tnpoints[2] = length(xx)\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(2,maxpoints))\n\t\tyall <- array(NA, c(2,maxpoints))\n\n\t\txall[1,1:npoints[1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tyall[1,1:npoints[1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n\t\txall[2,1:npoints[2]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tyall[2,1:npoints[2]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(2)\n\t\tfor (i in c(1:2)) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(2))\n\t\tlty <- array(0,c(2))\n\t\tlwd <- array(0,c(2))\n\n\t\tldesc[1] <- sprintf(\"KM for Class %d\", classnum)\n\t\tlty[1] = 1\n\t\tlwd[1] = 2.5\n\n\t\tldesc[2] <- sprintf(\"ES for Class %d\", classnum)\n\t\tlty[2] = 1\n\t\tlwd[2] = 2.5\n\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t}\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.sample.vs.estimated.logcumulative\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.sample.vs.estimated.logcumulative('ex6.21.gh5','T')\n#\nmplus.plot.survival.sample.vs.estimated.logcumulative <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Sample log cumulative hazard curve compared with\\nestimated log cumulative baseline hazard curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(2*dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tnpoints[2*(i-1)+1] = length(xx)\n\t\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tnpoints[2*i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(2*dims[1],maxpoints))\n\t\tyall <- array(NA, c(2*dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tyall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.compute.survival.sample.logcumulative.values(file,surv_idx,i)\n\n\t\t\txall[2*i,1:npoints[2*i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tyall[2*i,1:npoints[2*i]] <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(2*dims[1])\n\t\tfor (i in c(1:(2*dims[1]))) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(2*dims[1]))\n\t\tlty <- array(0,c(2*dims[1]))\n\t\tlwd <- array(0,c(2*dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[2*(i-1)+1] <- sprintf(\"LC for Class %d\", i)\n\t\t\tlty[2*(i-1)+1] = 1\n\t\t\tlwd[2*(i-1)+1] = 2.5\n\n\t\t\tldesc[2*i] <- sprintf(\"ELC for Class %d\", i)\n\t\t\tlty[2*i] = 1\n\t\t\tlwd[2*i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\tnpoints <- array(0, c(2))\n\t\txx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tnpoints[1] = length(xx)\n\t\txx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tnpoints[2] = length(xx)\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(2,maxpoints))\n\t\tyall <- array(NA, c(2,maxpoints))\n\n\t\txall[1,1:npoints[1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tyall[1,1:npoints[1]] <-mplus.compute.survival.sample.logcumulative.values(file,surv_idx,classnum)\n\n\t\txall[2,1:npoints[2]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tyall[2,1:npoints[2]] <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,classnum)\n\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(2)\n\t\tfor (i in c(1:2)) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(2))\n\t\tlty <- array(0,c(2))\n\t\tlwd <- array(0,c(2))\n\n\t\tldesc[1] <- sprintf(\"LC for Class %d\", classnum)\n\t\tlty[1] = 1\n\t\tlwd[1] = 2.5\n\n\t\tldesc[2] <- sprintf(\"ELC for Class %d\", classnum)\n\t\tlty[2] = 1\n\t\tlwd[2] = 2.5\n\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t}\n}\n\n\n\n\n######################################################################################################\n# Functions for Discrete survival plots\n######################################################################################################\n\n#========================================================================\n# mplus.list.discrete.survival.variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.discrete.survival.variables('ex6.21.gh5')\n#\nmplus.list.discrete.survival.variables <- function(file) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- discrete survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n#\tcat(c(\"\\nList of variables to use in the following functions:\\n\"))\n#\tcat(c(\" - mplus.compute.irt.icc\\n\"))\n#\tcat(c(\" - mplus.plot.irt.icc\\n\"))\n\n\tcat(c(\"\\nList of survival variables:\\n\"))\n\n\tfor (i in c(1:props[1])) {\n\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\tcstr <- sprintf(\"%s\", label)\n\t\tcstr <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", cstr, perl=TRUE)\n\t\tprint(cstr)\n\t}\n}\n\n\n#========================================================================\n# mplus.get.discrete.survival.kaplanmeier.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.discrete.survival.kaplanmeier.values('ex6.21.gh5','T')\n#\nmplus.get.discrete.survival.kaplanmeier.values <- function(file,survvar,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n\tif (missing(classnum)) {\n\t\tdatastr <- sprintf(\"kaplan_meier1\")\n\t} else {\n\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\tdims <- attr(classes,'dim')\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\t\tdatastr <- sprintf(\"kaplan_meier%d\", classnum)\n\t}\n\tkmvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\tif (missing(time)) {\n\t\treturn(kmvals[,2])\n\t} else {\n\t\treturn(kmvals[,1])\n\t}\n}\n\n#========================================================================\n# mplus.get.discrete.survival.baseline.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tsurvvar2 - ending survival variable for getting sequential time\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.discrete.survival.baseline.values('ex6.21.gh5','T')\n#\nmplus.get.discrete.survival.baseline.values <- function(file,survvar,survvar2,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tif (!(missing(survvar2))) {\n\t\tif (is.character(survvar2)) {\n\t\t\tsurv_idx2 <- 0\n\t\t\tfor (i in c(1:props[1])) {\n\t\t\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\t\tif (label == survvar2) {\n\t\t\t\t\tsurv_idx2 = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (surv_idx2 == 0) {\n\t\t\t\tstop(\"- unknown survival variable:  \", survvar2)\n\t\t\t}\n\t\t} else {\n\t\t\tif (survvar2 <= 0 || survvar2 > props[1]) {\n\t\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t\t}\n\t\t\tsurv_idx2 = survvar2\n\t\t}\n\t}\n\n\tif (missing(survvar2)) {\n\t\tgroupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n\t\tif (missing(classnum)) {\n\t\t\tdatastr <- sprintf(\"estimated_survival\")\n\t\t} else {\n\t\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\t\tdims <- attr(classes,'dim')\n\t\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\t\tstop(\"Class number is out of range.\")\n\t\t\t}\n\t\t\tdatastr <- sprintf(\"estimated_survival%d\", classnum)\n\t\t}\n\t\tesvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\t\tif (missing(time)) {\n\t\t\treturn(esvals[,2])\n\t\t} else {\n\t\t\treturn(esvals[,1])\n\t\t}\n\t} else {\n\t\t# ending survival variable given so we need to link them sequentially\n\t\tylast <- 1\n\t\txlast <- 0\n\t\tdata <- vector()\n\t\ttime <- vector()\n\t\tcount <- 0\n\t\tfor (s in c(surv_idx:surv_idx2)) {\n\t\t\tgroupstr <- sprintf(\"discrete_survival_data/survival%d\", s)\n\t\t\tif (missing(classnum)) {\n\t\t\t\tdatastr <- sprintf(\"estimated_survival\")\n\t\t\t} else {\n\t\t\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\t\t\tdims <- attr(classes,'dim')\n\t\t\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\t\t\tstop(\"Class number is out of range.\")\n\t\t\t\t}\n\t\t\t\tdatastr <- sprintf(\"estimated_survival%d\", classnum)\n\t\t\t}\n\t\t\tesvals1 <- mplus.get.group.dataset(file,groupstr,datastr)\n\t\t\t\n\t\t\tif (s == surv_idx) {\n\t\t\t\tcount <- length(esvals1[,1])\n\t\t\t\tdata[1:count] <- esvals1[,1]\n\t\t\t\ttime[1:count] <- estvals[,2]\n\t\t\t} else {\n\t\t\t\tn <- length(estvals1[,1])\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n#========================================================================\n# mplus.get.discrete.survival.basehazard.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.discrete.survival.basehazard.values('ex6.21.gh5','T')\n#\nmplus.get.discrete.survival.basehazard.values <- function(file,survvar,classnum,time) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tif (missing(survvar)) {\n\t\tstop(\"The survival variable must be given.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n\tif (missing(classnum)) {\n\t\tdatastr <- sprintf(\"basehazard\")\n\t} else {\n\t\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\t\tdims <- attr(classes,'dim')\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\t\tdatastr <- sprintf(\"basehazard%d\", classnum)\n\t}\n\tbhvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n\tif (missing(time)) {\n\t\treturn(bhvals[,2])\n\t} else {\n\t\treturn(bhvals[,1])\n\t}\n}\n\n\n#========================================================================\n# mplus.plot.discrete.survival.kaplanmeier\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.discrete.survival.kaplanmeier('ex6.21.gh5','T')\n#\nmplus.plot.discrete.survival.kaplanmeier <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Kaplan-Meier curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tnpoints[i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(dims[1],maxpoints))\n\t\tyall <- array(NA, c(dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[i,1:npoints[i]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tyall[i,1:npoints[i]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(dims[1])\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(dims[1]))\n\t\tlty <- array(0,c(dims[1]))\n\t\tlwd <- array(0,c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"- class number is out of range\")\n\t\t}\n\n\t\txx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tyy <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n\t\tplot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(xx,yy,col='red')\n\t}\n}\n\n\n\n#========================================================================\n# mplus.plot.discrete.survival.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.discrete.survival.baseline('ex6.21.gh5','T')\n#\nmplus.plot.discrete.survival.baseline <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Estimated baseline survival curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tnpoints[i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(dims[1],maxpoints))\n\t\tyall <- array(NA, c(dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[i,1:npoints[i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tyall[i,1:npoints[i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n\t\tcolors <- rainbow(dims[1])\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(dims[1]))\n\t\tlty <- array(0,c(dims[1]))\n\t\tlwd <- array(0,c(dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[i] <- sprintf(\"Class %d\", i)\n\t\t\tlty[i] = 1\n\t\t\tlwd[i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\txx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tyy <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n\t\tplot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\t\tlines(xx,yy,col='red')\n\t}\n}\n\n\n#========================================================================\n# mplus.plot.discrete.survival.kaplanmeier.vs.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.discrete.survival.kaplanmeier.vs.baseline('ex6.21.gh5','T')\n#\nmplus.plot.discrete.survival.kaplanmeier.vs.baseline <- function(file,survvar=1,classnum) {\n\tif (missing(file)) {\n\t\tstop(\"- name of the GH5 file is required\")\n\t}\n\tif (!(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\t# check if survival data exists\n\tif ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n\t\tstop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n\t}\n\n\tprops <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n\tif (is.character(survvar)) {\n\t\tsurv_idx <- 0\n\t\tfor (i in c(1:props[1])) {\n\t\t\tcstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n\t\t\tlabel <- mplus.get.group.attribute(file,cstr,'label')\n\t\t\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\t\t\tif (label == survvar) {\n\t\t\t\tsurv_idx = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (surv_idx == 0) {\n\t\t\tstop(\"- unknown survival variable:  \", survvar)\n\t\t}\n\t} else {\n\t\tif (survvar <= 0 || survvar > props[1]) {\n\t\t\tstop(\"- index for the survival variable is out of range\")\n\t\t}\n\t\tsurv_idx = survvar\n\t}\n\n\tgroupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n\tlabel <- mplus.get.group.attribute(file,groupstr,'label')\n\tlabel <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n\tclasses <- mplus.get.group.dataset(file,'/','model_group_labels')\n\tdims <- attr(classes,'dim')\n\n\tcstr <- sprintf(\"Kaplan-Meier curve compared with\\nestimated baseline survival curve for %s\", label)\n\n\tif (missing(classnum)) {\n\t\tnpoints <- array(0, c(2*dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tnpoints[2*(i-1)+1] = length(xx)\n\t\t\txx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tnpoints[2*i] = length(xx)\n\t\t}\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(2*dims[1],maxpoints))\n\t\tyall <- array(NA, c(2*dims[1],maxpoints))\n\n\t\tfor (i in c(1:dims[1])) {\n\t\t\txall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n\t\t\tyall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i)\n\n\t\t\txall[2*i,1:npoints[2*i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n\t\t\tyall[2*i,1:npoints[2*i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i)\n\t\t}\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n')\n\n\t\tcolors <- rainbow(2*dims[1])\n\t\tfor (i in c(1:(2*dims[1]))) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(2*dims[1]))\n\t\tlty <- array(0,c(2*dims[1]))\n\t\tlwd <- array(0,c(2*dims[1]))\n\t\tfor (i in c(1:dims[1])) {\n\t\t\tldesc[2*(i-1)+1] <- sprintf(\"KM for Class %d\", i)\n\t\t\tlty[2*(i-1)+1] = 1\n\t\t\tlwd[2*(i-1)+1] = 2.5\n\n\t\t\tldesc[2*i] <- sprintf(\"ES for Class %d\", i)\n\t\t\tlty[2*i] = 1\n\t\t\tlwd[2*i] = 2.5\n\t\t}\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t} else {\n\t\tif (classnum <= 0 || classnum > dims[1]) {\n\t\t\tstop(\"Class number is out of range.\")\n\t\t}\n\n\t\tnpoints <- array(0, c(2))\n\t\txx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tnpoints[1] = length(xx)\n\t\txx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tnpoints[2] = length(xx)\n\t\tmaxpoints = max(npoints)\n\n\t\txall <- array(NA, c(2,maxpoints))\n\t\tyall <- array(NA, c(2,maxpoints))\n\n\t\txall[1,1:npoints[1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n\t\tyall[1,1:npoints[1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n\t\txall[2,1:npoints[2]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n\t\tyall[2,1:npoints[2]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n\t\tplot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n')\n\n\t\tcolors <- rainbow(2)\n\t\tfor (i in c(1:2)) {\n\t\t\tlines(xall[i,],yall[i,],col=colors[i])\n\t\t}\n\n\t\tldesc <- array(0,c(2))\n\t\tlty <- array(0,c(2))\n\t\tlwd <- array(0,c(2))\n\n\t\tldesc[1] <- sprintf(\"KM for Class %d\", classnum)\n\t\tlty[1] = 1\n\t\tlwd[1] = 2.5\n\n\t\tldesc[2] <- sprintf(\"ES for Class %d\", classnum)\n\t\tlty[2] = 1\n\t\tlwd[2] = 2.5\n\n\t\tlegend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\t}\n}\n\n\n\n\n\n######################################################################################################\n# Supporting functions\n######################################################################################################\n\n\n##########################################################################\n#\n# mplus.get.group.attribute - supporting function for getting attribute\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   groupstr - the name of the group for the attribute\n#   attrstr - the name of the attribute\n#\n# eg. mplus.get.attribute('ex8.1.gh5','individual_data','var_names')\n#\nmplus.get.group.attribute <- function(file, groupstr, attrstr) {\n\tif ( !(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\tfid <- H5Fopen(file)\n\tgid <- H5Gopen(fid, groupstr)\n\tatid <- H5Aopen(gid, attrstr)\n\n\tattr <- H5Aread(atid)\n\n\tH5Aclose(atid)\n\tH5Gclose(gid)\n\tH5Fclose(fid)\n\n\tattr <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", attr, perl=TRUE)\n\n\treturn(attr)\n}\n\n##########################################################################\n#\n# mplus.get.group.attribute - supporting function for getting attribute\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   groupstr - the name of the group for the attribute\n#   attrstr - the name of the attribute\n#\n# eg. mplus.get.attribute('ex8.1.gh5','individual_data','var_names')\n#\nmplus.get.dataset.attribute <- function(file, datastr, attrstr) {\n\tif ( !(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\tfid <- H5Fopen(file)\n\tdid <- H5Dopen(fid, datastr)\n\tatid <- H5Aopen(did, attrstr)\n\n\tattr <- H5Aread(atid)\n\n\tH5Aclose(atid)\n\tH5Dclose(did)\n\tH5Fclose(fid)\n\n\treturn(attr)\n}\n\n##########################################################################\n#\n# mplus.get.group.dataset - supporting function for getting dataset\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   groupstr - the name of the group for the attribute\n#   datastr - the name of the attribute\n#\n# eg. mplus.get.group.dataset('ex8.1.gh5','bayesian_data','statements')\n#\nmplus.get.group.dataset <- function(file, groupstr, datastr) {\n\tif ( !(file.exists(file))) {\n\t\tcstr <- paste(\"- file does not exist:\",file,\"\\n\")\n\t\tstop(cstr)\n\t}\n\n\tgh5 <- h5dump(file, load=TRUE)\n\n\tfid <- H5Fopen(file)\n\tgid <- H5Gopen(fid, groupstr)\n\tdtid <- H5Dopen(gid, datastr)\n\n\tdata <- H5Dread(dtid)\n\n\tH5Dclose(dtid)\n\tH5Gclose(gid)\n\tH5Fclose(fid)\n\n\treturn(data)\n}\n\nestimate_mode <- function(x) {\n\td <- density(x)\n\td$x[which.max(d$y)]\n}\n\n\n\n######################################################################################################\n# Math functions\n######################################################################################################\n\nlin <- function(y, link) {\n\tif (link == 0) {\n\t\tx <- logistic(y)\n\t} else {\n\t\tx <- pnorm(y, mean=0, sd=1)\n\t}\n\tx\n}\n\nlogistic <- function(y) {\n\tif (y > 50) {\n\t\tx = 1\n\t} else if (y > -50) {\n\t\tx = 1 / (1 + exp(-y))\n\t} else {\n\t\tx = 0\n\t}\n\n\tx\n}\n\n\n\n\n",
    "created" : 1426029376574.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2335927068",
    "id" : "6BD38FA9",
    "lastKnownWriteTime" : 1426028236,
    "path" : "~/GitHub/psy564/Scripts/MPlus/mplus.R",
    "project_path" : "Scripts/MPlus/mplus.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}